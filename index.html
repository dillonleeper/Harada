<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Harada Open Window 64 – Dillon</title>
  <style>
    :root {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      background: #ffffff;
      color: #1d1d1f;
      
      /* Pillar Colors - Soft Pastels */
      --pillar-p1: #E8F0FE; /* Soft Blue - Skill & Craft */
      --pillar-p2: #F1ECFF; /* Soft Violet - Technical */
      --pillar-p3: #EAF7EF; /* Soft Green - Career */
      --pillar-p4: #E6F6F4; /* Soft Teal - SaaS */
      --pillar-p5: #FFF1E6; /* Soft Peach - Art Business */
      --pillar-p6: #FDECEF; /* Soft Pink - Brand */
      --pillar-p7: #FFF8E1; /* Soft Yellow - Health */
      --pillar-p8: #F2F3F7; /* Soft Gray-Lavender - Identity */
    }

    body {
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      max-width: 980px;
      width: 100%;
      gap: 16px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: #1d1d1f;
      letter-spacing: -0.01em;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #6e6e73;
      text-align: center;
      max-width: 700px;
    }

    .grid-wrapper {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      max-width: 980px;
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 1px solid #d2d2d7;
      border-radius: 12px;
      padding: 16px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .pillar-box, .center-box {
      display: flex;
      flex-direction: column;
      gap: 4px;
      aspect-ratio: 1 / 1;
      width: 100%;
      height: 100%;
    }

    .pillar-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-align: center;
      padding: 8px;
      border-radius: 8px;
      background: #f1f3f6;
      border: 1px solid #c0c2c7;
      color: #1d1d1f;
      grid-column: 2;
      grid-row: 2;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      overflow: auto;
      word-wrap: break-word;
      hyphens: auto;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.03) inset;
    }

    /* Pillar Title Colors */
    .pillar-title[data-pillar="P1"] { background: var(--pillar-p1); }
    .pillar-title[data-pillar="P2"] { background: var(--pillar-p2); }
    .pillar-title[data-pillar="P3"] { background: var(--pillar-p3); }
    .pillar-title[data-pillar="P4"] { background: var(--pillar-p4); }
    .pillar-title[data-pillar="P5"] { background: var(--pillar-p5); }
    .pillar-title[data-pillar="P6"] { background: var(--pillar-p6); }
    .pillar-title[data-pillar="P7"] { background: var(--pillar-p7); }
    .pillar-title[data-pillar="P8"] { background: var(--pillar-p8); }

    .center-title {
      font-size: 0.7rem;
      font-weight: 700;
      text-align: center;
      padding: 8px;
      border-radius: 8px;
      background: #f3f4f6;
      border: 1.5px solid #b8bac0;
      color: #1d1d1f;
      grid-column: 2;
      grid-row: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      line-height: 1.2;
      overflow: hidden;
      box-shadow: 0 0 0 2px rgba(184, 186, 192, 0.2), 0 0 8px rgba(0, 0, 0, 0.04);
    }

    .center-title strong {
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #1d1d1f;
    }

    .center-title span {
      font-size: 0.6rem;
      font-weight: 400;
      line-height: 1.3;
    }

    .pillar-card {
      font-size: 0.6rem;
      font-weight: 600;
      text-align: center;
      padding: 6px;
      border-radius: 8px;
      background: #f3f4f6;
      border: 1px solid #d2d2d7;
      border-left: 2px solid #d2d2d7;
      color: #1d1d1f;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.2;
      word-wrap: break-word;
      hyphens: auto;
      overflow: hidden;
      transition: border-color 0.15s ease;
    }

    /* Pillar Card Colors - Left Border Accent */
    .pillar-card[data-pillar="P1"] { border-left-color: #a8c5ff; }
    .pillar-card[data-pillar="P2"] { border-left-color: #c5b8ff; }
    .pillar-card[data-pillar="P3"] { border-left-color: #90d4a8; }
    .pillar-card[data-pillar="P4"] { border-left-color: #7dd4ca; }
    .pillar-card[data-pillar="P5"] { border-left-color: #ffb366; }
    .pillar-card[data-pillar="P6"] { border-left-color: #ffa8b8; }
    .pillar-card[data-pillar="P7"] { border-left-color: #ffd966; }
    .pillar-card[data-pillar="P8"] { border-left-color: #b8bac7; }

    .tasks-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 6px;
      flex: 1;
      width: 100%;
      height: 100%;
    }

    .task-cell {
      font-size: 0.65rem;
      line-height: 1.3;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #c4c4c7;
      background: #f3f4f6;
      color: #1d1d1f;
      cursor: pointer;
      user-select: none;
      aspect-ratio: 1 / 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 2px;
      position: relative;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      overflow: hidden;
      scrollbar-width: none;
    }

    .task-cell::-webkit-scrollbar {
      display: none;
    }

    /* Task Cell Pillar Color Accents - Pastel Tinted Backgrounds */
    .task-cell[data-pillar="P1"] { background: rgba(232, 240, 254, 0.33); }
    .task-cell[data-pillar="P2"] { background: rgba(241, 236, 255, 0.33); }
    .task-cell[data-pillar="P3"] { background: rgba(234, 247, 239, 0.33); }
    .task-cell[data-pillar="P4"] { background: rgba(230, 246, 244, 0.33); }
    .task-cell[data-pillar="P5"] { background: rgba(255, 241, 230, 0.33); }
    .task-cell[data-pillar="P6"] { background: rgba(253, 236, 239, 0.33); }
    .task-cell[data-pillar="P7"] { background: rgba(255, 248, 225, 0.33); }
    .task-cell[data-pillar="P8"] { background: rgba(242, 243, 247, 0.33); }

    .task-title {
      font-weight: 600;
      font-size: 0.7rem;
      color: #1d1d1f;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
    }

    .task-hint {
      font-weight: 400;
      font-size: 0.6rem;
      color: #6e6e73;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
    }

    .task-cell:hover {
      border-color: #86868b;
      background: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .task-cell.completed {
      border-color: #d2d2d7;
      border-left-width: 3px;
      opacity: 0.7;
    }

    /* Completed task backgrounds use pillar colors */
    .task-cell.completed[data-pillar="P1"] { background: var(--pillar-p1); }
    .task-cell.completed[data-pillar="P2"] { background: var(--pillar-p2); }
    .task-cell.completed[data-pillar="P3"] { background: var(--pillar-p3); }
    .task-cell.completed[data-pillar="P4"] { background: var(--pillar-p4); }
    .task-cell.completed[data-pillar="P5"] { background: var(--pillar-p5); }
    .task-cell.completed[data-pillar="P6"] { background: var(--pillar-p6); }
    .task-cell.completed[data-pillar="P7"] { background: var(--pillar-p7); }
    .task-cell.completed[data-pillar="P8"] { background: var(--pillar-p8); }

    /* Fallback for tasks without pillar */
    .task-cell.completed:not([data-pillar]) { background: #e8e8ed; }

    .task-cell.completed::after {
      content: "✔";
      position: absolute;
      right: 6px;
      top: 4px;
      font-size: 0.8rem;
      color: #1d1d1f;
      opacity: 0.5;
    }

    .meta {
      font-size: 0.8rem;
      color: #86868b;
      text-align: right;
      font-weight: 400;
      margin: 0;
      white-space: nowrap;
    }

    .today-reflection {
      max-width: 980px;
      width: 100%;
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 14px 18px;
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .reflection-count {
      font-size: 0.85rem;
      font-weight: 600;
      color: #1d1d1f;
      white-space: nowrap;
    }

    .pillar-dots {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .pillar-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #e5e5ea;
      transition: all 0.2s ease;
    }

    .pillar-dot.active {
      transform: scale(1.1);
    }

    .pillar-dot[data-pillar="P1"].active { background: var(--pillar-p1); border: 1.5px solid #a8c5ff; }
    .pillar-dot[data-pillar="P2"].active { background: var(--pillar-p2); border: 1.5px solid #c5b8ff; }
    .pillar-dot[data-pillar="P3"].active { background: var(--pillar-p3); border: 1.5px solid #90d4a8; }
    .pillar-dot[data-pillar="P4"].active { background: var(--pillar-p4); border: 1.5px solid #7dd4ca; }
    .pillar-dot[data-pillar="P5"].active { background: var(--pillar-p5); border: 1.5px solid #ffb366; }
    .pillar-dot[data-pillar="P6"].active { background: var(--pillar-p6); border: 1.5px solid #ffa8b8; }
    .pillar-dot[data-pillar="P7"].active { background: var(--pillar-p7); border: 1.5px solid #ffd966; }
    .pillar-dot[data-pillar="P8"].active { background: var(--pillar-p8); border: 1.5px solid #b8bac7; }

    .reflection-insight {
      flex: 1;
      font-size: 0.8rem;
      color: #6e6e73;
      line-height: 1.4;
    }

    .stats {
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 12px 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      display: none;
    }

    .stats h2 {
      font-size: 1rem;
      margin: 0 0 8px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    th, td {
      border: 1px solid #d2d2d7;
      padding: 0;
      text-align: left;
    }

    td:first-child {
      padding: 6px 8px;
    }

    .progress-cell {
      position: relative;
      min-height: 32px;
      padding: 0;
    }

    .progress-cell-container {
      position: relative;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f3f6;
      border-radius: 6px;
      overflow: hidden;
      margin: 6px 8px;
    }

    .progress-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 6px;
    }

    .progress-value {
      position: relative;
      z-index: 1;
      font-weight: 600;
      font-size: 0.8rem;
      color: #1d1d1f;
      padding: 6px 8px;
    }

    th {
      background: #f1f3f6;
      color: #1d1d1f;
      font-weight: 600;
    }

    tr:nth-child(even) td {
      background: #fbfbfd;
    }

    tr:nth-child(odd) td {
      background: #ffffff;
    }

    .stats-summary {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #6e6e73;
    }

    .today {
      font-weight: 600;
      color: #1d1d1f;
    }

    .pillar-balance {
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .pillar-balance h2 {
      font-size: 1rem;
      margin: 0 0 12px 0;
    }

    .balance-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .time-range-selector {
      display: flex;
      gap: 4px;
      background: #f1f3f6;
      border-radius: 6px;
      padding: 2px;
    }

    .time-range-btn {
      font-size: 0.7rem;
      padding: 4px 10px;
      border: none;
      background: transparent;
      color: #6e6e73;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .time-range-btn:hover {
      background: #e5e5ea;
      color: #1d1d1f;
    }

    .time-range-btn.active {
      background: #ffffff;
      color: #1d1d1f;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .balance-content {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 20px;
      align-items: stretch;
    }

    .radar-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .radar-canvas {
      width: 320px;
      height: 320px;
      display: block;
    }

    .radar-legend {
      font-size: 0.65rem;
      color: #6e6e73;
      line-height: 1.6;
      padding: 8px;
      background: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e5ea;
    }

    .radar-legend-item {
      display: flex;
      gap: 4px;
    }

    .radar-legend-label {
      font-weight: 600;
      color: #1d1d1f;
      min-width: 20px;
    }

    .balance-insights {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      height: 100%;
      gap: 6px;
    }

    .insight-card {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 10px 14px;
    }

    .insight-label {
      font-size: 0.7rem;
      color: #86868b;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      border: 1px solid #86868b;
      border-radius: 50%;
      font-size: 0.6rem;
      color: #86868b;
      cursor: help;
      position: relative;
      flex-shrink: 0;
    }

    .info-icon:hover {
      border-color: #1d1d1f;
      color: #1d1d1f;
    }

    .info-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      width: 240px;
      padding: 8px 12px;
      background: #1d1d1f;
      color: #ffffff;
      font-size: 0.7rem;
      font-weight: 400;
      line-height: 1.4;
      border-radius: 6px;
      text-transform: none;
      letter-spacing: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .info-icon:hover .info-tooltip {
      opacity: 1;
    }

    .info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #1d1d1f;
    }

    .insight-value {
      font-size: 1.4rem;
      font-weight: 700;
      color: #1d1d1f;
      font-variant-numeric: tabular-nums;
    }

    .insight-description {
      font-size: 0.72rem;
      color: #6e6e73;
      margin-top: 4px;
      line-height: 1.4;
    }

    .insight-secondary {
      font-size: 0.68rem;
      color: #86868b;
      margin-top: 2px;
      line-height: 1.3;
      font-style: italic;
    }

    .neglected-pillar {
      background: #fff5e6;
      border-color: #ffb366;
    }

    .neglected-pillar .insight-value {
      color: #ff8800;
    }

    .overweighted-pillar {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-left-width: 3px;
    }

    .overweighted-pillar .insight-value {
      color: #1d1d1f;
    }

    .stability-card {
      background: #f5f5f7;
      border-color: #d1d1d6;
    }

    .stability-card .insight-value {
      color: #1d1d1f;
    }

    .balance-footer {
      margin-top: 6px;
      padding: 8px 10px;
      background: #f5f5f7;
      border-top: 1px solid #e5e5ea;
      border-radius: 4px;
      font-size: 0.7rem;
      color: #6e6e73;
      line-height: 1.4;
      text-align: center;
      font-style: italic;
    }

    .streak-momentum {
      max-width: 980px;
      width: 100%;
      background: #fafbfc;
      border: 1px solid #e5e5ea;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      height: 48px;
      box-sizing: border-box;
    }

    .hud-stat {
      display: flex;
      align-items: baseline;
      gap: 6px;
      white-space: nowrap;
    }

    .hud-label {
      font-size: 0.7rem;
      color: #86868b;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .hud-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #1d1d1f;
      font-variant-numeric: tabular-nums;
    }

    .hud-momentum {
      flex: 1;
      max-width: 280px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .momentum-mini-bars {
      flex: 1;
      display: flex;
      align-items: flex-end;
      gap: 3px;
      height: 24px;
    }

    .momentum-mini-bar {
      flex: 1;
      background: #d1d1d6;
      border-radius: 2px;
      min-height: 2px;
      transition: all 0.3s ease;
    }

    .momentum-mini-bar.has-data {
      background: #007AFF;
    }

    .momentum-mini-bar.today {
      background: #FF9500;
    }

    @media (max-width: 900px) {
      .grid-wrapper {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }
    }

    /* Mobile-first tuning for smaller screens */
    @media (max-width: 720px) {
      body {
        padding: 12px;
      }

      h1 {
        font-size: 1.4rem;
      }

      .subtitle {
        font-size: 0.85rem;
      }

      .grid-wrapper {
        gap: 12px;
      }

      .today-reflection {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 12px 14px;
      }

      .reflection-count {
        font-size: 0.8rem;
      }

      .reflection-insight {
        font-size: 0.75rem;
      }

      .pillar-title {
        font-size: 0.9rem;
      }

      .subpillars-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }

      .tasks-grid {
        grid-template-columns: 1fr;
      }

      .task-cell {
        font-size: 0.8rem;
        min-height: 48px;
        padding: 10px 12px;
      }

      .stats {
        padding: 10px;
      }

      table {
        font-size: 0.75rem;
      }

      th,
      td {
        padding: 4px;
      }

      .streak-momentum {
        flex-direction: column;
        height: auto;
        gap: 8px;
        padding: 10px 12px;
      }

      .hud-stat {
        width: 100%;
        justify-content: space-between;
      }

      .hud-momentum {
        width: 100%;
        max-width: none;
      }

      .balance-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .balance-content {
        grid-template-columns: 1fr;
      }

      .radar-canvas {
        width: 100%;
        height: auto;
        max-width: 320px;
        margin: 0 auto;
      }

      .radar-legend {
        font-size: 0.6rem;
      }
    }
  </style>
</head>
<body>
  <div class="header-container">
    <h1>Harada Open Window 64</h1>
    <div class="meta" id="dateDisplay"></div>
  </div>

  <div class="grid-wrapper" id="gridWrapper">
    <!-- Pillars & center will be injected here by JavaScript -->
  </div>

  <div class="today-reflection">
    <div class="reflection-count" id="reflectionCount">—</div>
    <div class="pillar-dots" id="pillarDots">
      <div class="pillar-dot" data-pillar="P1"></div>
      <div class="pillar-dot" data-pillar="P2"></div>
      <div class="pillar-dot" data-pillar="P3"></div>
      <div class="pillar-dot" data-pillar="P4"></div>
      <div class="pillar-dot" data-pillar="P5"></div>
      <div class="pillar-dot" data-pillar="P6"></div>
      <div class="pillar-dot" data-pillar="P7"></div>
      <div class="pillar-dot" data-pillar="P8"></div>
    </div>
    <div class="reflection-insight" id="reflectionInsight">Loading...</div>
  </div>

  <div class="stats">
    <h2>Progress Overview</h2>
    <table>
      <thead>
        <tr>
          <th>Pillar</th>
          <th>Tasks Completed Today</th>
          <th>Total Completions (All Time)</th>
        </tr>
      </thead>
      <tbody id="statsBody"></tbody>
    </table>
    <div class="stats-summary" id="statsSummary"></div>
  </div>

  <div class="pillar-balance">
    <div class="balance-header">
      <h2>Balance Over Time</h2>
      <div class="time-range-selector">
        <button class="time-range-btn" data-range="7">Last 7 days</button>
        <button class="time-range-btn active" data-range="30">Last 30 days</button>
        <button class="time-range-btn" data-range="90">Last 90 days</button>
        <button class="time-range-btn" data-range="ytd">YTD</button>
        <button class="time-range-btn" data-range="all">All Time</button>
      </div>
    </div>
    <div class="balance-content">
      <div class="radar-section">
        <canvas id="radarChart" class="radar-canvas" width="320" height="320"></canvas>
        <div class="radar-legend">
          <div class="radar-legend-item"><span class="radar-legend-label">P1</span><span>Skill & Craft Mastery</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P2</span><span>Technical Leverage (AI / Code / Data)</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P3</span><span>Career Money Systems</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P4</span><span>SaaS / Business Systems</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P5</span><span>Art Business Systems</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P6</span><span>Brand & Audience</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P7</span><span>Health & Energy</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P8</span><span>Identity & Discipline</span></div>
        </div>
      </div>
      <div class="balance-insights">
        <div class="insight-card">
          <div class="insight-label">
            Balance Score
            <span class="info-icon">
              i
              <span class="info-tooltip">Measures how evenly your effort is distributed across all 8 pillars. Higher scores (80-100) indicate balanced focus, while lower scores suggest concentration in fewer areas.</span>
            </span>
          </div>
          <div class="insight-value" id="balanceScore">—</div>
          <div class="insight-description" id="balanceDescription">Loading...</div>
        </div>
        <div class="insight-card">
          <div class="insight-label">
            Balance Trend
            <span class="info-icon">
              i
              <span class="info-tooltip">Compares your current balance score to the previous equivalent period. Positive values indicate improvement in distributing focus across pillars.</span>
            </span>
          </div>
          <div class="insight-value" id="balanceTrend">—</div>
          <div class="insight-description" id="balanceTrendDescription">Loading...</div>
        </div>
        <div class="insight-card overweighted-pillar" id="focusPatternCard">
          <div class="insight-label">
            Focus Pattern
            <span class="info-icon">
              i
              <span class="info-tooltip">Shows where your attention is concentrated and which areas might benefit from more focus.</span>
            </span>
          </div>
          <div class="insight-value" id="focusPatternPrimary">—</div>
          <div class="insight-description" id="focusPatternDescription">Loading...</div>
          <div class="insight-secondary" id="focusPatternSecondary"></div>
        </div>
        <div class="insight-card stability-card">
          <div class="insight-label">
            Focus Stability
            <span class="info-icon">
              i
              <span class="info-tooltip">Measures consistency of your pillar focus from day to day (0-10 scale). Steady patterns (8-10) show reliable attention. Dynamic patterns (0-4) reflect frequent shifts.</span>
            </span>
          </div>
          <div class="insight-value" id="stabilityScore">—</div>
          <div class="insight-description" id="stabilityDescription">Loading...</div>
        </div>
        <div class="balance-footer" id="balanceFooter">Loading balance insights...</div>
      </div>
    </div>
  </div>

  <script>
    // Pillar color map
    const pillarColors = {
      'P1': '#E8F0FE', // Soft Blue
      'P2': '#F1ECFF', // Soft Violet
      'P3': '#EAF7EF', // Soft Green
      'P4': '#E6F6F4', // Soft Teal
      'P5': '#FFF1E6', // Soft Peach
      'P6': '#FDECEF', // Soft Pink
      'P7': '#FFF8E1', // Soft Yellow
      'P8': '#F2F3F7'  // Soft Gray-Lavender
    };

    const pillars = [
      {
        id: "P1",
        name: "Skill & Craft Mastery",
        tasks: [
          { title: "Sketch", hint: "New Idea" },
          { title: "Study", hint: "Form" },
          { title: "Study", hint: "Light" },
          { title: "Explore", hint: "Composition" },
          { title: "Gesture", hint: "Figures" },
          { title: "Control", hint: "Edges" },
          { title: "Simplify", hint: "Reference" },
          { title: "Refine", hint: "Piece" }
        ]
      },
      {
        id: "P2",
        name: "Technical Leverage (AI / Code / Data)",
        tasks: [
          { title: "Write", hint: "Code" },
          { title: "Fix", hint: "Bug" },
          { title: "Refactor", hint: "Code" },
          { title: "Explore", hint: "Data" },
          { title: "Test", hint: "App Flow" },
          { title: "Learn", hint: "One Concept" },
          { title: "Read", hint: "Blocked Docs" },
          { title: "Sketch", hint: "Feature Idea" }
        ]
      },
      {
        id: "P3",
        name: "Career / Money Systems",
        tasks: [
          { title: "Research", hint: "Roles & Paths" },
          { title: "Learn", hint: "Career Skill" },
          { title: "Apply", hint: "New Role" },
          { title: "Build", hint: "Work Leverage" },
          { title: "Pitch", hint: "Business Idea" },
          { title: "Reach Out", hint: "New Contact" },
          { title: "Practice", hint: "Interview Answers" },
          { title: "Study", hint: "Industry Trends" }
        ]
      },
      {
        id: "P4",
        name: "SaaS / Business Systems (SellerIQ)",
        tasks: [
          { title: "Build", hint: "Feature" },
          { title: "Improve", hint: "Chat" },
          { title: "Explore", hint: "Seller Data" },
          { title: "Fix", hint: "Flow" },
          { title: "Clarify", hint: "Idea" },
          { title: "Write", hint: "Notes" },
          { title: "Talk To", hint: "User" },
          { title: "Demo", hint: "App" }
        ]
      },
      {
        id: "P5",
        name: "Art Business Systems",
        tasks: [
          { title: "Choose", hint: "Art Idea" },
          { title: "Make", hint: "Art" },
          { title: "Capture", hint: "Process" },
          { title: "Edit", hint: "Media" },
          { title: "Write", hint: "Caption" },
          { title: "Publish", hint: "Art" },
          { title: "Explore", hint: "Product Idea" },
          { title: "Improve", hint: "Consistency" }
        ]
      },
      {
        id: "P6",
        name: "Brand & Audience",
        tasks: [
          { title: "Post", hint: "Something" },
          { title: "Share", hint: "Process" },
          { title: "Write", hint: "Content Idea" },
          { title: "Engage", hint: "People" },
          { title: "Plan", hint: "Tomorrow" },
          { title: "Show", hint: "Personality" },
          { title: "Observe", hint: "Creators" },
          { title: "Stay", hint: "Visible" }
        ]
      },
      {
        id: "P7",
        name: "Health & Energy",
        tasks: [
          { title: "Train", hint: "Workout" },
          { title: "Eat", hint: "Enough" },
          { title: "Drink", hint: "Water" },
          { title: "Sleep", hint: "On Time" },
          { title: "Stretch", hint: "Posture & Hips" },
          { title: "Take", hint: "Supplements" },
          { title: "Break", hint: "A Sweat" },
          { title: "Recover", hint: "Rest Day" }
        ]
      },
      {
        id: "P8",
        name: "Identity & Discipline",
        tasks: [
          { title: "Start", hint: "Hard Thing" },
          { title: "Delay", hint: "Phone" },
          { title: "Shut Down", hint: "Evening" },
          { title: "Regain", hint: "Attention" },
          { title: "Keep", hint: "Promise" },
          { title: "Tidy", hint: "One Area" },
          { title: "Be", hint: "Present" },
          { title: "Decide", hint: "Today's Focus" }
        ]
      }
    ];

    const STORAGE_TODAY_KEY = "haradaTodayState";
    const STORAGE_STATS_KEY = "haradaStatsAllTime";
    const STORAGE_HISTORY_KEY = "haradaHistory";
    const STORAGE_STREAKS_KEY = "haradaStreaks";
    const MIN_TASKS_FOR_STREAK = 1; // Configurable threshold

    function getTodayString() {
      const d = new Date();
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function formatPrettyDate() {
      const d = new Date();
      return d.toLocaleDateString(undefined, {
        weekday: "long",
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    let todayState = null;
    let statsAllTime = null;
    let dailyHistory = null;
    let streakData = null;
    let selectedTimeRange = "30";

    function loadState() {
      const today = getTodayString();
      const rawToday = localStorage.getItem(STORAGE_TODAY_KEY);
      const rawStats = localStorage.getItem(STORAGE_STATS_KEY);
      const rawHistory = localStorage.getItem(STORAGE_HISTORY_KEY);
      const rawStreaks = localStorage.getItem(STORAGE_STREAKS_KEY);

      try {
        todayState = rawToday ? JSON.parse(rawToday) : null;
      } catch {
        todayState = null;
      }
      if (!todayState || todayState.date !== today) {
        // Save yesterday's count before resetting
        if (todayState && todayState.date) {
          const yesterdayCount = Object.keys(todayState.completed).length;
          if (dailyHistory) {
            dailyHistory[todayState.date] = yesterdayCount;
            localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));
          }
        }
        todayState = { date: today, completed: {} };
        localStorage.setItem(STORAGE_TODAY_KEY, JSON.stringify(todayState));
      }

      try {
        statsAllTime = rawStats ? JSON.parse(rawStats) : null;
      } catch {
        statsAllTime = null;
      }
      if (!statsAllTime) {
        statsAllTime = {};
        localStorage.setItem(STORAGE_STATS_KEY, JSON.stringify(statsAllTime));
      }

      try {
        dailyHistory = rawHistory ? JSON.parse(rawHistory) : {};
      } catch {
        dailyHistory = {};
      }
      localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));

      try {
        streakData = rawStreaks ? JSON.parse(rawStreaks) : null;
      } catch {
        streakData = null;
      }
      if (!streakData) {
        streakData = { current: 0, best: 0 };
        localStorage.setItem(STORAGE_STREAKS_KEY, JSON.stringify(streakData));
      }
    }

    function saveTodayState() {
      localStorage.setItem(STORAGE_TODAY_KEY, JSON.stringify(todayState));
    }

    function saveStats() {
      localStorage.setItem(STORAGE_STATS_KEY, JSON.stringify(statsAllTime));
    }

    function calculateStreaks() {
      const today = getTodayString();
      const todayCount = Object.keys(todayState.completed).length;
      
      // Update today in history
      dailyHistory[today] = todayCount;
      localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));

      // Get all dates sorted descending
      const allDates = Object.keys(dailyHistory).sort().reverse();
      
      // Calculate current streak
      let currentStreak = 0;
      const dateIterator = new Date();
      
      while (true) {
        const dateStr = dateIterator.toISOString().split('T')[0];
        const count = dailyHistory[dateStr] || 0;
        
        if (count >= MIN_TASKS_FOR_STREAK) {
          currentStreak++;
        } else {
          break;
        }
        
        // Move to previous day
        dateIterator.setDate(dateIterator.getDate() - 1);
        
        // Safety: don't go back more than 365 days
        if (currentStreak > 365) break;
      }

      // Calculate best streak
      let bestStreak = 0;
      let tempStreak = 0;
      let previousDate = null;
      
      for (const dateStr of allDates) {
        const count = dailyHistory[dateStr];
        const currentDate = new Date(dateStr);
        
        if (count >= MIN_TASKS_FOR_STREAK) {
          if (previousDate === null) {
            tempStreak = 1;
          } else {
            const dayDiff = Math.floor((previousDate - currentDate) / (1000 * 60 * 60 * 24));
            if (dayDiff === 1) {
              tempStreak++;
            } else {
              bestStreak = Math.max(bestStreak, tempStreak);
              tempStreak = 1;
            }
          }
        } else {
          bestStreak = Math.max(bestStreak, tempStreak);
          tempStreak = 0;
        }
        
        previousDate = currentDate;
      }
      bestStreak = Math.max(bestStreak, tempStreak);

      streakData.current = currentStreak;
      streakData.best = Math.max(streakData.best, bestStreak);
      localStorage.setItem(STORAGE_STREAKS_KEY, JSON.stringify(streakData));
    }

    function getLast7Days() {
      const days = [];
      const today = new Date();
      
      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        const dayName = date.toLocaleDateString(undefined, { weekday: 'short' });
        const count = dailyHistory[dateStr] || 0;
        const isToday = dateStr === getTodayString();
        days.push({ date: dateStr, dayName, count, isToday });
      }
      
      return days;
    }

    function updateStreakUI() {
      calculateStreaks();

      document.getElementById('currentStreak').textContent = streakData.current;
      document.getElementById('bestStreak').textContent = streakData.best;
      
      // Render mini momentum bars
      const last7 = getLast7Days();
      const chart = document.getElementById('momentumChart');
      chart.innerHTML = '';
      
      const maxCount = Math.max(...last7.map(d => d.count), 8);
      
      last7.forEach(day => {
        const bar = document.createElement('div');
        bar.className = 'momentum-mini-bar';
        
        if (day.count > 0) {
          bar.classList.add('has-data');
        }
        if (day.isToday) {
          bar.classList.add('today');
        }
        
        const heightPercent = day.count > 0 ? Math.max((day.count / maxCount) * 100, 8) : 8;
        bar.style.height = `${heightPercent}%`;
        bar.title = `${day.dayName}: ${day.count} tasks`;
        
        chart.appendChild(bar);
      });
    }

    function createPillarBox(pillar) {
      const box = document.createElement("div");
      box.className = "pillar-box";

      const tasksGrid = document.createElement("div");
      tasksGrid.className = "tasks-grid";

      const title = document.createElement("div");
      title.className = "pillar-title";
      title.textContent = pillar.name;
      title.dataset.pillar = pillar.id;

      pillar.tasks.forEach((task, index) => {
        const cell = document.createElement("div");
        cell.className = "task-cell";
        const cellId = `${pillar.id}-T${index + 1}`;
        cell.dataset.id = cellId;
        cell.dataset.pillar = pillar.id;
        
        const titleEl = document.createElement("div");
        titleEl.className = "task-title";
        titleEl.textContent = task.title;
        
        const hintEl = document.createElement("div");
        hintEl.className = "task-hint";
        hintEl.textContent = task.hint;
        
        cell.appendChild(titleEl);
        cell.appendChild(hintEl);

        if (todayState.completed[cellId]) {
          cell.classList.add("completed");
        }

        cell.addEventListener("click", () => {
          toggleTask(cell);
        });

        tasksGrid.appendChild(cell);
      });

      tasksGrid.appendChild(title);
      box.appendChild(tasksGrid);
      return box;
    }

    function createCenterBox() {
      const box = document.createElement("div");
      box.className = "center-box";

      const tasksGrid = document.createElement("div");
      tasksGrid.className = "tasks-grid";

      // Define explicit grid placement for each pillar
      const pillarLayout = [
        { pillar: pillars[0], row: 1, col: 1 }, // P1: Skill & Craft Mastery
        { pillar: pillars[1], row: 1, col: 2 }, // P2: Technical Leverage
        { pillar: pillars[2], row: 1, col: 3 }, // P3: Career Money Systems
        { pillar: pillars[7], row: 2, col: 1 }, // P8: Identity & Discipline
        { pillar: pillars[3], row: 2, col: 3 }, // P4: SaaS / Business Systems
        { pillar: pillars[6], row: 3, col: 1 }, // P7: Health & Energy
        { pillar: pillars[5], row: 3, col: 2 }, // P6: Brand & Audience
        { pillar: pillars[4], row: 3, col: 3 }  // P5: Art Business Systems
      ];

      // Create pillar cards with explicit positioning
      pillarLayout.forEach(({ pillar, row, col }) => {
        const pillarCard = document.createElement("div");
        pillarCard.className = "pillar-card";
        pillarCard.textContent = pillar.name;
        pillarCard.dataset.pillar = pillar.id;
        pillarCard.style.gridRow = row;
        pillarCard.style.gridColumn = col;
        tasksGrid.appendChild(pillarCard);
      });

      // Create center goal card (row 2, col 2)
      const centerTitle = document.createElement("div");
      centerTitle.className = "center-title";
      centerTitle.innerHTML = `
        <strong>GOAL</strong>
        <span>Live From What I Build</span>
      `;
      
      tasksGrid.appendChild(centerTitle);
      box.appendChild(tasksGrid);
      return box;
    }

    function renderGrid() {
      const gridWrapper = document.getElementById("gridWrapper");
      gridWrapper.innerHTML = "";

      const layoutOrder = ["P1", "P2", "P3", "P8", "CENTER", "P4", "P7", "P6", "P5"];

      layoutOrder.forEach((id) => {
        if (id === "CENTER") {
          gridWrapper.appendChild(createCenterBox());
        } else {
          const pillar = pillars.find((p) => p.id === id);
          gridWrapper.appendChild(createPillarBox(pillar));
        }
      });
    }

    function toggleTask(cell) {
      const cellId = cell.dataset.id;
      const isCompleted = !!todayState.completed[cellId];

      if (isCompleted) {
        delete todayState.completed[cellId];
        cell.classList.remove("completed");

        if (statsAllTime[cellId] && statsAllTime[cellId] > 0) {
          statsAllTime[cellId] -= 1;
        }
      } else {
        todayState.completed[cellId] = true;
        cell.classList.add("completed");
        statsAllTime[cellId] = (statsAllTime[cellId] || 0) + 1;
      }

      saveTodayState();
      saveStats();
      updateTodayReflection();
      updatePillarBalance();
    }

    function updateTodayReflection() {
      // Count tasks completed today per pillar
      const pillarTouches = {};
      pillars.forEach(p => pillarTouches[p.id] = 0);
      
      let totalToday = 0;
      Object.keys(todayState.completed).forEach(taskId => {
        const pillarId = taskId.split('-')[0];
        if (pillarTouches[pillarId] !== undefined) {
          pillarTouches[pillarId]++;
          totalToday++;
        }
      });

      // Update count
      const pillarsCount = Object.values(pillarTouches).filter(c => c > 0).length;
      document.getElementById('reflectionCount').textContent = 
        totalToday === 0 ? 'No tasks yet' : 
        totalToday === 1 ? '1 task' : 
        `${totalToday} tasks`;

      // Update dots
      document.querySelectorAll('.pillar-dot').forEach(dot => {
        const pillarId = dot.dataset.pillar;
        if (pillarTouches[pillarId] > 0) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });

      // Update insight with coaching voice
      const insightEl = document.getElementById('reflectionInsight');
      if (totalToday === 0) {
        insightEl.textContent = "Your grid awaits—each task is a step forward.";
      } else if (pillarsCount === 1) {
        const activePillar = pillars.find(p => pillarTouches[p.id] > 0);
        insightEl.textContent = `Deep focus in ${activePillar.name} today.`;
      } else if (pillarsCount === 8) {
        insightEl.textContent = "You touched all 8 pillars—beautifully balanced.";
      } else if (pillarsCount >= 5) {
        insightEl.textContent = `Broad engagement across ${pillarsCount} pillars today.`;
      } else {
        insightEl.textContent = `Your attention centered on ${pillarsCount} pillars today.`;
      }
    }

    function updateStatsUI() {
      // Hidden table - keeping for potential future use
      const statsBody = document.getElementById("statsBody");
      const statsSummary = document.getElementById("statsSummary");
      if (!statsBody) return;
      
      statsBody.innerHTML = "";

      const pillarTotalsToday = {};
      const pillarTotalsAllTime = {};
      let totalToday = 0;
      let totalAllTime = 0;

      pillars.forEach((p) => {
        pillarTotalsToday[p.id] = 0;
        pillarTotalsAllTime[p.id] = 0;
      });

      Object.keys(todayState.completed).forEach((cellId) => {
        const [pillarId] = cellId.split("-");
        if (pillarTotalsToday[pillarId] !== undefined) {
          pillarTotalsToday[pillarId] += 1;
          totalToday += 1;
        }
      });

      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split("-");
        if (pillarTotalsAllTime[pillarId] !== undefined) {
          pillarTotalsAllTime[pillarId] += count;
          totalAllTime += count;
        }
      });

      pillars.forEach((p) => {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        const tdToday = document.createElement("td");
        const tdAll = document.createElement("td");

        // Name cell (plain text)
        tdName.textContent = p.name;

        // Today progress cell (out of 8)
        const todayCount = pillarTotalsToday[p.id];
        const todayPercent = Math.min((todayCount / 8) * 100, 100);
        tdToday.className = "progress-cell";
        tdToday.innerHTML = `
          <div class="progress-cell-container">
            <div class="progress-fill" style="width: ${todayPercent}%; background-color: ${pillarColors[p.id]};"></div>
            <div class="progress-value">${todayCount}</div>
          </div>
        `;

        // All time progress cell (out of 365)
        const allTimeCount = pillarTotalsAllTime[p.id];
        const allTimePercent = Math.min((allTimeCount / 365) * 100, 100);
        tdAll.className = "progress-cell";
        tdAll.innerHTML = `
          <div class="progress-cell-container">
            <div class="progress-fill" style="width: ${allTimePercent}%; background-color: ${pillarColors[p.id]};"></div>
            <div class="progress-value">${allTimeCount}</div>
          </div>
        `;

        tr.appendChild(tdName);
        tr.appendChild(tdToday);
        tr.appendChild(tdAll);
        
        // Debug: Verify three cells
        const cellCount = tr.children.length;
        if (cellCount !== 3) {
          console.warn(`⚠️ Row for ${p.name} has ${cellCount} cells instead of 3!`);
        }
        
        statsBody.appendChild(tr);
      });

      statsSummary.innerHTML = `
        <span class="today">Today:</span> ${totalToday} tasks completed across all pillars.<br>
        <span class="today">All time:</span> ${totalAllTime} total task completions tracked.
      `;

      updatePillarBalance();
    }

    function calculateFocusStability(datesInRange) {
      // Filter to days with non-zero completions
      const nonZeroDays = datesInRange.filter(dateStr => (dailyHistory[dateStr] || 0) > 0);
      
      if (nonZeroDays.length < 3) {
        return {
          score: null,
          classification: null,
          description: "Complete tasks across at least 3 different days to unlock stability insights."
        };
      }

      // Get all-time pillar distribution for approximation
      const allTimePillarTotals = {};
      pillars.forEach(p => allTimePillarTotals[p.id] = 0);
      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split('-');
        if (allTimePillarTotals[pillarId] !== undefined) {
          allTimePillarTotals[pillarId] += count;
        }
      });
      const allTimeTotal = Object.values(allTimePillarTotals).reduce((sum, v) => sum + v, 0);
      
      // For each day, approximate pillar shares using all-time distribution
      const dailyShares = {}; // pillarId -> array of daily shares
      pillars.forEach(p => dailyShares[p.id] = []);
      
      nonZeroDays.forEach(dateStr => {
        const dayTotal = dailyHistory[dateStr];
        if (dayTotal > 0) {
          pillars.forEach(p => {
            // Approximate pillar count for this day using all-time ratio
            const pillarRatio = allTimeTotal > 0 ? allTimePillarTotals[p.id] / allTimeTotal : 1/8;
            const estimatedPillarCount = dayTotal * pillarRatio;
            const share = estimatedPillarCount / dayTotal;
            dailyShares[p.id].push(share);
          });
        }
      });
      
      // Calculate standard deviation for each pillar's daily shares
      const pillarStdDevs = [];
      pillars.forEach(p => {
        const shares = dailyShares[p.id];
        if (shares.length > 0) {
          const mean = shares.reduce((sum, s) => sum + s, 0) / shares.length;
          const variance = shares.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / shares.length;
          const stdDev = Math.sqrt(variance);
          pillarStdDevs.push(stdDev);
        }
      });
      
      // Average the standard deviations to get volatility index
      const volatilityIndex = pillarStdDevs.reduce((sum, sd) => sum + sd, 0) / pillarStdDevs.length;
      
      // Normalize and convert to 0-10 stability score (inverse of volatility)
      // Cap volatilityIndex at 0.25 for normalization
      const cappedVolatility = Math.min(volatilityIndex, 0.25);
      const normalizedVolatility = cappedVolatility / 0.25;
      const stabilityScore = Math.round((1 - normalizedVolatility) * 10);
      const clampedScore = Math.max(0, Math.min(10, stabilityScore));
      
      // Classify
      let classification, description;
      if (clampedScore >= 8) {
        classification = "Steady";
        description = "Your focus pattern has been consistent.";
      } else if (clampedScore >= 5) {
        classification = "Moderate";
        description = "Your attention shifts moderately between pillars.";
      } else {
        classification = "Dynamic";
        description = "Your focus moves frequently across different areas.";
      }
      
      return {
        score: clampedScore,
        classification: classification,
        description: description
      };
    }

    function updatePillarBalance() {
      // Calculate pillar totals from dailyHistory for selected time range
      const pillarTotals = {};
      pillars.forEach(p => pillarTotals[p.id] = 0);
      
      const today = new Date();
      let datesInRange = [];
      
      // Determine which dates to include based on selected range
      if (selectedTimeRange === "ytd") {
        // Year to Date: from Jan 1 of current year through today
        const yearStart = new Date(today.getFullYear(), 0, 1);
        const daysSinceYearStart = Math.floor((today - yearStart) / (1000 * 60 * 60 * 24)) + 1;
        for (let i = 0; i < daysSinceYearStart; i++) {
          const date = new Date(yearStart);
          date.setDate(date.getDate() + i);
          datesInRange.push(date.toISOString().split('T')[0]);
        }
      } else if (selectedTimeRange === "all") {
        // All Time: use all dates in history
        datesInRange = Object.keys(dailyHistory);
      } else {
        // Last N days
        const days = parseInt(selectedTimeRange);
        for (let i = 0; i < days; i++) {
          const date = new Date(today);
          date.setDate(date.getDate() - i);
          datesInRange.push(date.toISOString().split('T')[0]);
        }
      }
      
      // Get today's pillar totals
      const todayPillarTotals = {};
      pillars.forEach(p => todayPillarTotals[p.id] = 0);
      Object.keys(todayState.completed).forEach(cellId => {
        const [pillarId] = cellId.split('-');
        if (todayPillarTotals[pillarId] !== undefined) {
          todayPillarTotals[pillarId]++;
        }
      });
      
      // Get all-time pillar totals
      const allTimePillarTotals = {};
      pillars.forEach(p => allTimePillarTotals[p.id] = 0);
      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split('-');
        if (allTimePillarTotals[pillarId] !== undefined) {
          allTimePillarTotals[pillarId] += count;
        }
      });
      
      // Calculate total completions in the date range
      const recentDaysTotal = datesInRange.reduce((sum, dateStr) => sum + (dailyHistory[dateStr] || 0), 0);
      const allTimeTotal = Object.values(allTimePillarTotals).reduce((sum, v) => sum + v, 0);
      
      // Approximate recent pillar distribution using all-time ratios
      // Note: This is an approximation since we don't store per-pillar daily data
      pillars.forEach(p => {
        const pillarRatio = allTimeTotal > 0 ? allTimePillarTotals[p.id] / allTimeTotal : 1/8;
        pillarTotals[p.id] = Math.round(recentDaysTotal * pillarRatio);
      });
      
      const values = pillars.map(p => pillarTotals[p.id] || 0);
      const total = values.reduce((sum, v) => sum + v, 0);
      
      if (total === 0) {
        document.getElementById('balanceScore').textContent = '—';
        document.getElementById('balanceDescription').textContent = 'Complete tasks to see your balance.';
        document.getElementById('neglectedPillar').textContent = '—';
        document.getElementById('neglectedDescription').textContent = 'No data yet.';
        document.getElementById('overweightedPillar').textContent = '—';
        document.getElementById('overweightedDescription').textContent = 'No data yet.';
        document.getElementById('stabilityScore').textContent = '—';
        document.getElementById('stabilityDescription').textContent = 'No data yet.';
        return;
      }

      // Calculate coefficient of variation (lower = more balanced)
      const mean = total / values.length;
      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      const stdDev = Math.sqrt(variance);
      const cv = mean > 0 ? (stdDev / mean) : 0;
      
      // Convert to 0-100 scale (invert so 100 = perfectly balanced)
      const balanceScore = Math.round(Math.max(0, 100 - (cv * 100)));
      
      document.getElementById('balanceScore').textContent = balanceScore;
      
      let description = '';
      if (balanceScore >= 80) description = 'Well-distributed across all pillars.';
      else if (balanceScore >= 60) description = 'Mostly balanced with a few areas standing out.';
      else if (balanceScore >= 40) description = 'Some concentration in select areas.';
      else description = 'Focus is heavily concentrated.';
      
      document.getElementById('balanceDescription').textContent = description;

      // Find most neglected and most active pillars
      const minValue = Math.min(...values);
      const minIndex = values.indexOf(minValue);
      const neglectedPillar = pillars[minIndex];
      
      const maxValue = Math.max(...values);
      const maxIndex = values.indexOf(maxValue);
      const activePillar = pillars[maxIndex];
      const percentage = total > 0 ? Math.round((maxValue / total) * 100) : 0;
      
      // Update Focus Pattern card (merged Most Active + Most Neglected)
      document.getElementById('focusPatternPrimary').textContent = activePillar.name;
      document.getElementById('focusPatternDescription').textContent = 
        `Your current anchor (${percentage}% of activity).`;
      document.getElementById('focusPatternSecondary').textContent = 
        neglectedPillar.id !== activePillar.id ? 
        `${neglectedPillar.name} could use attention.` : 
        'Focus is evenly distributed.';
      
      // Set dynamic pillar color border for Focus Pattern card
      const focusPatternCard = document.getElementById('focusPatternCard');
      const pillarColorMap = {
        'P1': '#a8c5ff', 'P2': '#c5b8ff', 'P3': '#90d4a8', 'P4': '#7dd4ca',
        'P5': '#ffb366', 'P6': '#ffa8b8', 'P7': '#ffd966', 'P8': '#b8bac7'
      };
      focusPatternCard.style.borderLeftColor = pillarColorMap[activePillar.id] || '#e5e5ea';

      // Calculate and display balance trend
      const previousDatesInRange = [];
      const rangeLength = datesInRange.length;
      
      if (selectedTimeRange === "ytd" || selectedTimeRange === "all") {
        // For YTD and All Time, compare to same period length ending before current range
        const oldestDate = new Date(Math.min(...datesInRange.map(d => new Date(d))));
        for (let i = 0; i < rangeLength; i++) {
          const date = new Date(oldestDate);
          date.setDate(date.getDate() - rangeLength + i);
          previousDatesInRange.push(date.toISOString().split('T')[0]);
        }
      } else {
        // For Last N days, compare to previous N days
        const days = parseInt(selectedTimeRange);
        const startDate = new Date(today);
        startDate.setDate(startDate.getDate() - days);
        for (let i = 0; i < days; i++) {
          const date = new Date(startDate);
          date.setDate(date.getDate() - days + i);
          previousDatesInRange.push(date.toISOString().split('T')[0]);
        }
      }
      
      // Calculate previous period balance score
      const previousTotal = previousDatesInRange.reduce((sum, dateStr) => sum + (dailyHistory[dateStr] || 0), 0);
      
      if (previousTotal === 0 || previousDatesInRange.length < 3) {
        document.getElementById('balanceTrend').textContent = '—';
        document.getElementById('balanceTrendDescription').textContent = 'Not enough prior data to compare.';
      } else {
        // Approximate previous pillar distribution
        const previousPillarTotals = {};
        pillars.forEach(p => {
          const pillarRatio = allTimeTotal > 0 ? allTimePillarTotals[p.id] / allTimeTotal : 1/8;
          previousPillarTotals[p.id] = Math.round(previousTotal * pillarRatio);
        });
        
        const previousValues = pillars.map(p => previousPillarTotals[p.id] || 0);
        const previousMean = previousTotal / previousValues.length;
        const previousVariance = previousValues.reduce((sum, v) => sum + Math.pow(v - previousMean, 2), 0) / previousValues.length;
        const previousStdDev = Math.sqrt(previousVariance);
        const previousCv = previousMean > 0 ? (previousStdDev / previousMean) : 0;
        const previousBalanceScore = Math.round(Math.max(0, 100 - (previousCv * 100)));
        
        const delta = balanceScore - previousBalanceScore;
        const absDelta = Math.abs(delta);
        
        if (delta > 0) {
          document.getElementById('balanceTrend').textContent = `+${delta}`;
          document.getElementById('balanceTrendDescription').textContent = 
            `More balanced than previous period (+${absDelta}).`;
        } else if (delta < 0) {
          document.getElementById('balanceTrend').textContent = `${delta}`;
          document.getElementById('balanceTrendDescription').textContent = 
            `Less balanced than previous period (-${absDelta}).`;
        } else {
          document.getElementById('balanceTrend').textContent = '0';
          document.getElementById('balanceTrendDescription').textContent = 
            'Same balance as previous period.';
        }
      }

      // Calculate and display focus stability
      const stability = calculateFocusStability(datesInRange);
      
      if (stability.score === null) {
        document.getElementById('stabilityScore').textContent = '—';
        document.getElementById('stabilityDescription').textContent = stability.description;
      } else {
        document.getElementById('stabilityScore').textContent = `${stability.classification} (${stability.score}/10)`;
        document.getElementById('stabilityDescription').textContent = stability.description;
      }

      // Update balance footer with contextual message
      const balanceFooter = document.getElementById('balanceFooter');
      const nonZeroDays = datesInRange.filter(dateStr => (dailyHistory[dateStr] || 0) > 0);
      
      if (nonZeroDays.length < 3) {
        balanceFooter.textContent = "Build a few more days of data to reveal deeper patterns.";
      } else if (balanceScore >= 75) {
        balanceFooter.textContent = "Your attention flows naturally across all areas.";
      } else if (balanceScore >= 50) {
        balanceFooter.textContent = "There's room to explore pillars beyond your anchors.";
      } else {
        balanceFooter.textContent = "Your energy is concentrated—intentional or opportunity?";
      }

      // Render radar chart
      renderRadarChart(values);
    }

    function renderRadarChart(values) {
      const canvas = document.getElementById('radarChart');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 120;
      const maxValue = Math.max(...values, 50); // Minimum scale of 50
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid circles
      ctx.strokeStyle = '#e5e5ea';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#d2d2d7';
      ctx.lineWidth = 1;
      pillars.forEach((pillar, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.stroke();
      });
      
      // Draw labels
      ctx.fillStyle = '#1d1d1f';
      ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      pillars.forEach((pillar, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const labelRadius = radius + 24;
        const x = centerX + Math.cos(angle) * labelRadius;
        const y = centerY + Math.sin(angle) * labelRadius;
        
        ctx.fillText(`P${i + 1}`, x, y);
      });
      
      // Draw data polygon
      ctx.fillStyle = 'rgba(0, 122, 255, 0.15)';
      ctx.strokeStyle = '#007AFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      values.forEach((value, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const valueRadius = (value / maxValue) * radius;
        const x = centerX + Math.cos(angle) * valueRadius;
        const y = centerY + Math.sin(angle) * valueRadius;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Draw data points
      ctx.fillStyle = '#007AFF';
      values.forEach((value, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const valueRadius = (value / maxValue) * radius;
        const x = centerX + Math.cos(angle) * valueRadius;
        const y = centerY + Math.sin(angle) * valueRadius;
        
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function init() {
      loadState();
      document.getElementById("dateDisplay").textContent =
        formatPrettyDate() + " · Daily progress resets";
      renderGrid();
      updateTodayReflection();
      updatePillarBalance();
      
      // Set up time range selector
      document.querySelectorAll('.time-range-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const range = e.target.dataset.range;
          selectedTimeRange = range;
          
          // Update active state
          document.querySelectorAll('.time-range-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          
          // Refresh balance view
          updatePillarBalance();
        });
      });
    }

    init();
  </script>
</body>
</html>
