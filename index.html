<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Harada Open Window 64 ‚Äì Dillon</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    /* Global box-sizing fix for all elements */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* Kill horizontal overflow globally - iOS Safari fix */
    html, body {
      overflow-x: hidden;
      width: 100%;
      margin: 0;
      padding: 0;
    }

    :root {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      background: #ffffff;
      color: #1d1d1f;
      
      /* Pillar Colors - Soft Pastels */
      --pillar-p1: #E8F0FE; /* Soft Blue - Skill & Craft */
      --pillar-p2: #F1ECFF; /* Soft Violet - Technical */
      --pillar-p3: #EAF7EF; /* Soft Green - Career */
      --pillar-p4: #E6F6F4; /* Soft Teal - SaaS */
      --pillar-p5: #FFF1E6; /* Soft Peach - Learning & Growth */
      --pillar-p6: #FDECEF; /* Soft Pink - Brand */
      --pillar-p7: #FFF8E1; /* Soft Yellow - Health */
      --pillar-p8: #F2F3F7; /* Soft Gray-Lavender - Identity */
    }

    body {
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      max-width: 980px;
      width: 100%;
      gap: 16px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: #1d1d1f;
      letter-spacing: -0.01em;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #6e6e73;
      text-align: center;
      max-width: 700px;
    }

    .grid-wrapper {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      max-width: 980px;
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 1px solid #d2d2d7;
      border-radius: 12px;
      padding: 16px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .pillar-box, .center-box {
      display: flex;
      flex-direction: column;
      gap: 4px;
      aspect-ratio: 1 / 1;
      width: 100%;
      height: 100%;
    }

    .pillar-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-align: center;
      padding: 8px;
      border-radius: 8px;
      background: #f1f3f6;
      border: 1px solid #c0c2c7;
      color: #1d1d1f;
      grid-column: 2;
      grid-row: 2;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      overflow: auto;
      word-wrap: break-word;
      hyphens: auto;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.03) inset;
    }

    /* Pillar Title Colors */
    .pillar-title[data-pillar="P1"] { background: var(--pillar-p1); }
    .pillar-title[data-pillar="P2"] { background: var(--pillar-p2); }
    .pillar-title[data-pillar="P3"] { background: var(--pillar-p3); }
    .pillar-title[data-pillar="P4"] { background: var(--pillar-p4); }
    .pillar-title[data-pillar="P5"] { background: var(--pillar-p5); }
    .pillar-title[data-pillar="P6"] { background: var(--pillar-p6); }
    .pillar-title[data-pillar="P7"] { background: var(--pillar-p7); }
    .pillar-title[data-pillar="P8"] { background: var(--pillar-p8); }

    .center-title {
      font-size: 0.7rem;
      font-weight: 700;
      text-align: center;
      padding: 8px;
      border-radius: 8px;
      background: #f3f4f6;
      border: 1.5px solid #b8bac0;
      color: #1d1d1f;
      grid-column: 2;
      grid-row: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      line-height: 1.2;
      overflow: hidden;
      box-shadow: 0 0 0 2px rgba(184, 186, 192, 0.2), 0 0 8px rgba(0, 0, 0, 0.04);
    }

    .center-title strong {
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #1d1d1f;
    }

    .center-title span {
      font-size: 0.6rem;
      font-weight: 400;
      line-height: 1.3;
    }

    .pillar-card {
      font-size: 0.6rem;
      font-weight: 600;
      text-align: center;
      padding: 6px;
      border-radius: 8px;
      background: #f3f4f6;
      border: 1px solid #d2d2d7;
      border-left: 2px solid #d2d2d7;
      color: #1d1d1f;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.2;
      word-wrap: break-word;
      hyphens: auto;
      overflow: hidden;
      transition: border-color 0.15s ease;
    }

    /* Pillar Card Colors - Left Border Accent */
    .pillar-card[data-pillar="P1"] { border-left-color: #a8c5ff; }
    .pillar-card[data-pillar="P2"] { border-left-color: #c5b8ff; }
    .pillar-card[data-pillar="P3"] { border-left-color: #90d4a8; }
    .pillar-card[data-pillar="P4"] { border-left-color: #7dd4ca; }
    .pillar-card[data-pillar="P5"] { border-left-color: #ffb366; }
    .pillar-card[data-pillar="P6"] { border-left-color: #ffa8b8; }
    .pillar-card[data-pillar="P7"] { border-left-color: #ffd966; }
    .pillar-card[data-pillar="P8"] { border-left-color: #b8bac7; }

    .tasks-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 6px;
      flex: 1;
      width: 100%;
      height: 100%;
    }

    .task-cell {
      font-size: 0.65rem;
      line-height: 1.3;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #c4c4c7;
      background: #f3f4f6;
      color: #1d1d1f;
      cursor: pointer;
      user-select: none;
      aspect-ratio: 1 / 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 2px;
      position: relative;
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      overflow: hidden;
      scrollbar-width: none;
    }

    .task-cell::-webkit-scrollbar {
      display: none;
    }

    /* Task Cell Pillar Color Accents - Pastel Tinted Backgrounds */
    .task-cell[data-pillar="P1"] { background: rgba(232, 240, 254, 0.33); }
    .task-cell[data-pillar="P2"] { background: rgba(241, 236, 255, 0.33); }
    .task-cell[data-pillar="P3"] { background: rgba(234, 247, 239, 0.33); }
    .task-cell[data-pillar="P4"] { background: rgba(230, 246, 244, 0.33); }
    .task-cell[data-pillar="P5"] { background: rgba(255, 241, 230, 0.33); }
    .task-cell[data-pillar="P6"] { background: rgba(253, 236, 239, 0.33); }
    .task-cell[data-pillar="P7"] { background: rgba(255, 248, 225, 0.33); }
    .task-cell[data-pillar="P8"] { background: rgba(242, 243, 247, 0.33); }

    .task-title {
      font-weight: 600;
      font-size: 0.65rem;
      color: #1d1d1f;
      width: 100%;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.2;
    }

    .task-hint {
      font-weight: 400;
      font-size: 0.55rem;
      color: #6e6e73;
      width: 100%;
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.2;
    }

    .task-cell:hover {
      border-color: #86868b;
      background: #ffffff;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .task-cell.completed {
      border-color: #d2d2d7;
      border-left-width: 3px;
      opacity: 0.7;
    }

    /* Completed task backgrounds use pillar colors */
    .task-cell.completed[data-pillar="P1"] { background: var(--pillar-p1); }
    .task-cell.completed[data-pillar="P2"] { background: var(--pillar-p2); }
    .task-cell.completed[data-pillar="P3"] { background: var(--pillar-p3); }
    .task-cell.completed[data-pillar="P4"] { background: var(--pillar-p4); }
    .task-cell.completed[data-pillar="P5"] { background: var(--pillar-p5); }
    .task-cell.completed[data-pillar="P6"] { background: var(--pillar-p6); }
    .task-cell.completed[data-pillar="P7"] { background: var(--pillar-p7); }
    .task-cell.completed[data-pillar="P8"] { background: var(--pillar-p8); }

    /* Fallback for tasks without pillar */
    .task-cell.completed:not([data-pillar]) { background: #e8e8ed; }

    .task-cell.completed::after {
      content: "‚úî";
      position: absolute;
      right: 6px;
      top: 4px;
      font-size: 0.8rem;
      color: #1d1d1f;
      opacity: 0.5;
    }

    /* Tooltip styling for task cells */
    .task-tooltip {
      position: fixed;
      background: rgba(29, 29, 31, 0.95);
      color: #ffffff;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 0.75rem;
      line-height: 1.4;
      max-width: 280px;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      word-wrap: break-word;
    }

    .task-tooltip.visible {
      opacity: 1;
    }

    .task-tooltip-title {
      font-weight: 600;
      font-size: 0.8rem;
      margin-bottom: 4px;
      color: #ffffff;
    }

    .task-tooltip-hint {
      font-weight: 400;
      font-size: 0.72rem;
      color: #e5e5ea;
      line-height: 1.3;
    }

    .meta {
      font-size: 0.8rem;
      color: #86868b;
      text-align: right;
      font-weight: 400;
      margin: 0;
      white-space: nowrap;
    }

    .today-reflection {
      display: none;
      max-width: 980px;
      width: 100%;
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 14px 18px;
      gap: 16px;
    }

    .reflection-count {
      font-size: 0.85rem;
      font-weight: 600;
      color: #1d1d1f;
      white-space: nowrap;
    }

    .pillar-dots {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .pillar-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #e5e5ea;
      transition: all 0.2s ease;
    }

    .pillar-dot.active {
      transform: scale(1.1);
    }

    .pillar-dot[data-pillar="P1"].active { background: var(--pillar-p1); border: 1.5px solid #a8c5ff; }
    .pillar-dot[data-pillar="P2"].active { background: var(--pillar-p2); border: 1.5px solid #c5b8ff; }
    .pillar-dot[data-pillar="P3"].active { background: var(--pillar-p3); border: 1.5px solid #90d4a8; }
    .pillar-dot[data-pillar="P4"].active { background: var(--pillar-p4); border: 1.5px solid #7dd4ca; }
    .pillar-dot[data-pillar="P5"].active { background: var(--pillar-p5); border: 1.5px solid #ffb366; }
    .pillar-dot[data-pillar="P6"].active { background: var(--pillar-p6); border: 1.5px solid #ffa8b8; }
    .pillar-dot[data-pillar="P7"].active { background: var(--pillar-p7); border: 1.5px solid #ffd966; }
    .pillar-dot[data-pillar="P8"].active { background: var(--pillar-p8); border: 1.5px solid #b8bac7; }

    .reflection-insight {
      flex: 1;
      font-size: 0.8rem;
      color: #6e6e73;
      line-height: 1.4;
    }

    .stats {
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 12px 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      margin-bottom: 24px;
    }

    .stats h2 {
      font-size: 1rem;
      margin: 0 0 8px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    th, td {
      border: 1px solid #d2d2d7;
      padding: 0;
      text-align: left;
    }

    th {
      background: #f1f3f6;
      color: #1d1d1f;
      font-weight: 600;
      padding: 6px 8px;
    }

    td:first-child {
      padding: 8px 10px;
    }

    .progress-cell {
      position: relative;
      min-height: 28px;
      padding: 0;
    }

    .progress-cell-container {
      position: relative;
      min-height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f3f6;
      border-radius: 4px;
      overflow: hidden;
      margin: 4px 6px;
    }

    .progress-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 4px;
    }

    .progress-value {
      position: relative;
      z-index: 1;
      font-weight: 600;
      font-size: 0.75rem;
      color: #1d1d1f;
      padding: 5px 8px;
    }

    tr:nth-child(even) td {
      background: #fbfbfd;
    }

    tr:nth-child(odd) td {
      background: #ffffff;
    }

    .stats-summary {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #6e6e73;
    }

    .today {
      font-weight: 600;
      color: #1d1d1f;
    }

    .achievements-section {
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 12px 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      margin-bottom: 24px;
    }

    .achievements-section h2 {
      font-size: 0.9rem;
      margin: 0 0 10px 0;
      font-weight: 600;
      color: #1d1d1f;
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 8px;
    }

    /* New Analytics Sections */
    .analytics-section {
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 16px 18px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      margin-bottom: 20px;
    }

    .analytics-section h2 {
      font-size: 1rem;
      margin: 0 0 14px 0;
      font-weight: 600;
      color: #1d1d1f;
    }

    .analytics-section h3 {
      font-size: 0.85rem;
      margin: 14px 0 8px 0;
      font-weight: 600;
      color: #1d1d1f;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Priority Alignment */
    .priority-grid {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .priority-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e5ea;
    }

    .priority-pillar-name {
      flex: 0 0 180px;
      font-weight: 600;
      font-size: 0.8rem;
      color: #1d1d1f;
    }

    .priority-bars {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
    }

    .priority-label {
      flex: 0 0 65px;
      color: #6e6e73;
      font-weight: 500;
    }

    .priority-bar-container {
      flex: 1;
      height: 24px;
      background: #e5e5ea;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .priority-bar {
      height: 100%;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      color: white;
    }

    .priority-status {
      flex: 0 0 140px;
      text-align: right;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .status-on-track { color: #34c759; }
    .status-under { color: #ff3b30; }
    .status-over { color: #ff9500; }

    /* Streaks Section */
    .streaks-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .streak-card {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 12px;
    }

    .streak-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .streak-icon {
      font-size: 1.2rem;
    }

    .streak-pillar-name {
      font-weight: 600;
      font-size: 0.8rem;
      color: #1d1d1f;
      flex: 1;
    }

    .streak-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #ff9500;
      margin-bottom: 4px;
    }

    .streak-best {
      font-size: 0.7rem;
      color: #6e6e73;
    }

    .streak-new-record {
      color: #34c759;
      font-weight: 600;
    }

    .at-risk-section {
      background: #fff5e6;
      border: 1px solid #ffb366;
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }

    .at-risk-title {
      font-weight: 600;
      font-size: 0.8rem;
      color: #ff8800;
      margin-bottom: 8px;
    }

    .at-risk-item {
      font-size: 0.75rem;
      color: #6e6e73;
      margin-bottom: 4px;
    }

    /* Recommendations Section */
    .recommendations-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .recommendation-item {
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #e5e5ea;
    }

    .recommendation-item.high-priority {
      background: #f0f9ff;
      border-color: #007aff;
    }

    .recommendation-item.dial-back {
      background: #fff5e6;
      border-color: #ff9500;
    }

    .recommendation-item.maintain {
      background: #f0fff4;
      border-color: #34c759;
    }

    .recommendation-title {
      font-weight: 600;
      font-size: 0.82rem;
      color: #1d1d1f;
      margin-bottom: 4px;
    }

    .recommendation-why {
      font-size: 0.72rem;
      color: #6e6e73;
      line-height: 1.4;
    }

    /* Weekly Summary */
    .summary-section {
      margin-bottom: 16px;
    }

    .summary-items {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .summary-item {
      font-size: 0.78rem;
      line-height: 1.5;
      color: #1d1d1f;
      padding-left: 20px;
      position: relative;
    }

    .summary-item::before {
      content: attr(data-icon);
      position: absolute;
      left: 0;
      font-size: 0.9rem;
    }

    /* Goal Metrics */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .metric-card {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 12px;
    }

    .metric-label {
      font-size: 0.7rem;
      color: #6e6e73;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      font-weight: 500;
    }

    .metric-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: #1d1d1f;
      margin-bottom: 2px;
    }

    .metric-change {
      font-size: 0.7rem;
      color: #6e6e73;
    }

    .metric-change.positive {
      color: #34c759;
    }

    /* Settings Panel */
    .settings-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #007aff;
      color: white;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
      transition: all 0.2s ease;
      z-index: 9999;
    }

    .settings-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 122, 255, 0.4);
    }

    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .settings-overlay.visible {
      display: flex;
    }

    .settings-panel {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .settings-header h2 {
      margin: 0;
      font-size: 1.2rem;
    }

    .settings-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #86868b;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    .settings-close:hover {
      background: #f5f5f7;
      color: #1d1d1f;
    }

    .settings-group {
      margin-bottom: 24px;
    }

    .settings-group h3 {
      font-size: 0.9rem;
      margin: 0 0 12px 0;
      color: #1d1d1f;
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid #f5f5f7;
    }

    .settings-row:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 0.82rem;
      color: #1d1d1f;
      flex: 1;
    }

    .settings-input {
      width: 80px;
      padding: 6px 10px;
      border: 1px solid #d2d2d7;
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
    }

    .settings-save-btn {
      background: #007aff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 16px;
    }

    .settings-save-btn:hover {
      background: #0051d5;
    }

    .badge-card {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 6px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: all 0.2s ease;
    }

    .badge-card.unlocked {
      background: #ffffff;
      border-color: #007AFF;
      box-shadow: 0 1px 4px rgba(0, 122, 255, 0.1);
    }

    .badge-card.locked {
      opacity: 0.5;
    }

    .badge-icon {
      font-size: 1.5rem;
      text-align: center;
      filter: grayscale(100%);
    }

    .badge-card.unlocked .badge-icon {
      filter: grayscale(0%);
    }

    .badge-name {
      font-size: 0.75rem;
      font-weight: 600;
      color: #1d1d1f;
      text-align: center;
    }

    .badge-description {
      font-size: 0.65rem;
      color: #6e6e73;
      text-align: center;
      line-height: 1.3;
    }

    .badge-date {
      font-size: 0.6rem;
      color: #007AFF;
      text-align: center;
      margin-top: 2px;
    }

    .growth-insights-section {
      max-width: 980px;
      width: 100%;
      background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .growth-insights-section h2 {
      font-size: 1rem;
      margin: 0 0 12px 0;
      font-weight: 600;
      color: #1d1d1f;
    }

    .growth-insights-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .growth-insight-item {
      background: #ffffff;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 12px 14px;
      font-size: 0.8rem;
      line-height: 1.5;
      color: #1d1d1f;
    }

    .growth-insight-item strong {
      color: #007AFF;
      font-weight: 600;
    }

    .growth-insight-item em {
      color: #6e6e73;
      font-style: italic;
    }

    .pillar-balance {
      margin-bottom: 24px;
      max-width: 980px;
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #d2d2d7;
      padding: 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    .pillar-balance h2 {
      font-size: 1rem;
      margin: 0 0 12px 0;
    }

    .balance-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .time-range-selector {
      display: flex;
      gap: 4px;
      background: #f1f3f6;
      border-radius: 6px;
      padding: 2px;
    }

    .time-range-btn {
      font-size: 0.7rem;
      padding: 4px 10px;
      border: none;
      background: transparent;
      color: #6e6e73;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .time-range-btn:hover {
      background: #e5e5ea;
      color: #1d1d1f;
    }

    .time-range-btn.active {
      background: #ffffff;
      color: #1d1d1f;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    .time-range-count {
      font-size: 0.65rem;
      color: #86868b;
      font-weight: 400;
      margin-left: 3px;
    }

    .time-range-btn.active .time-range-count {
      color: #6e6e73;
    }

    .activity-timeline {
      margin-bottom: 12px;
      padding: 10px 12px;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e5ea;
    }

    .timeline-header {
      font-size: 0.65rem;
      color: #6e6e73;
      margin-bottom: 6px;
      font-weight: 500;
    }

    .timeline-chart {
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 50px;
      padding: 2px 0;
    }

    .timeline-bar {
      flex: 1;
      background: #d1d1d6;
      border-radius: 2px 2px 0 0;
      min-height: 4px;
      transition: all 0.2s ease;
      position: relative;
      cursor: pointer;
    }

    .timeline-bar.has-data {
      background: linear-gradient(180deg, #007AFF 0%, #0051D5 100%);
    }

    .timeline-bar.is-today {
      background: linear-gradient(180deg, #34C759 0%, #248A3D 100%);
      box-shadow: 0 0 0 1px rgba(52, 199, 89, 0.3);
    }

    .timeline-bar:hover {
      opacity: 0.8;
      transform: translateY(-2px);
    }

    .timeline-bar-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-4px);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.65rem;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 100;
    }

    .timeline-bar:hover .timeline-bar-tooltip {
      opacity: 1;
    }

    .timeline-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 3px;
      font-size: 0.6rem;
      color: #86868b;
    }

    .balance-content {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 12px;
      align-items: start;
    }

    .radar-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .radar-canvas {
      width: 320px;
      height: 320px;
      display: block;
      cursor: crosshair;
    }

    .radar-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 1000;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .radar-tooltip.visible {
      opacity: 1;
    }

    .radar-tooltip-pillar {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .radar-tooltip-value {
      color: #94d3ff;
    }

    .radar-legend {
      font-size: 0.65rem;
      color: #6e6e73;
      line-height: 1.5;
      padding: 6px 8px;
      background: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e5ea;
    }

    .radar-legend-item {
      display: flex;
      gap: 4px;
    }

    .radar-legend-label {
      font-weight: 600;
      color: #1d1d1f;
      min-width: 20px;
    }

    .balance-insights {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 8px;
    }

    .insight-card {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
      border-radius: 8px;
      padding: 10px 12px;
    }

    .insight-label {
      font-size: 0.7rem;
      color: #86868b;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      border: 1px solid #86868b;
      border-radius: 50%;
      font-size: 0.6rem;
      color: #86868b;
      cursor: help;
      position: relative;
      flex-shrink: 0;
    }

    .info-icon:hover {
      border-color: #1d1d1f;
      color: #1d1d1f;
    }

    .info-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      width: 240px;
      padding: 8px 12px;
      background: #1d1d1f;
      color: #ffffff;
      font-size: 0.7rem;
      font-weight: 400;
      line-height: 1.4;
      border-radius: 6px;
      text-transform: none;
      letter-spacing: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .info-icon:hover .info-tooltip {
      opacity: 1;
    }

    .info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #1d1d1f;
    }

    .insight-value {
      font-size: 1.4rem;
      font-weight: 700;
      color: #1d1d1f;
      font-variant-numeric: tabular-nums;
    }

    .insight-description {
      font-size: 0.72rem;
      color: #6e6e73;
      margin-top: 4px;
      line-height: 1.4;
    }

    .insight-secondary {
      font-size: 0.68rem;
      color: #86868b;
      margin-top: 2px;
      line-height: 1.3;
      font-style: italic;
    }

    .neglected-pillar {
      background: #fff5e6;
      border-color: #ffb366;
    }

    .neglected-pillar .insight-value {
      color: #ff8800;
    }

    .overweighted-pillar {
      background: #f9fafb;
      border: 1px solid #e5e5ea;
    }

    .overweighted-pillar .insight-value {
      color: #1d1d1f;
    }

    .stability-card {
      background: #f5f5f7;
      border-color: #d1d1d6;
    }

    .stability-card .insight-value {
      color: #1d1d1f;
    }

    .balance-footer {
      margin-top: 6px;
      padding: 8px 10px;
      background: #f5f5f7;
      border-top: 1px solid #e5e5ea;
      border-radius: 4px;
      font-size: 0.7rem;
      color: #6e6e73;
      line-height: 1.4;
      text-align: center;
      font-style: italic;
    }

    .streak-momentum {
      max-width: 980px;
      width: 100%;
      background: #fafbfc;
      border: 1px solid #e5e5ea;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      height: 48px;
      box-sizing: border-box;
    }

    .hud-stat {
      display: flex;
      align-items: baseline;
      gap: 6px;
      white-space: nowrap;
    }

    .hud-label {
      font-size: 0.7rem;
      color: #86868b;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .hud-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #1d1d1f;
      font-variant-numeric: tabular-nums;
    }

    .hud-momentum {
      flex: 1;
      max-width: 280px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .momentum-mini-bars {
      flex: 1;
      display: flex;
      align-items: flex-end;
      gap: 3px;
      height: 24px;
    }

    .momentum-mini-bar {
      flex: 1;
      background: #d1d1d6;
      border-radius: 2px;
      min-height: 2px;
      transition: all 0.3s ease;
    }

    .momentum-mini-bar.has-data {
      background: #007AFF;
    }

    .momentum-mini-bar.today {
      background: #FF9500;
    }

    @media (max-width: 900px) {
      .grid-wrapper {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }
    }

    /* Mobile-first tuning for smaller screens */
    @media (max-width: 720px) {
      body {
        padding: 12px;
      }

      h1 {
        font-size: 1.4rem;
      }

      .subtitle {
        font-size: 0.85rem;
      }

      .grid-wrapper {
        gap: 12px;
      }

      .today-reflection {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 12px 14px;
      }

      .reflection-count {
        font-size: 0.8rem;
      }

      .reflection-insight {
        font-size: 0.75rem;
      }

      .pillar-title {
        font-size: 0.9rem;
      }

      .subpillars-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }

      .tasks-grid {
        grid-template-columns: 1fr;
      }

      .task-cell {
        font-size: 0.8rem;
        min-height: 48px;
        padding: 10px 12px;
      }

      .stats {
        padding: 10px;
      }

      table {
        font-size: 0.75rem;
      }

      th,
      td {
        padding: 4px;
      }

      .streak-momentum {
        flex-direction: column;
        height: auto;
        gap: 8px;
        padding: 10px 12px;
      }

      .hud-stat {
        width: 100%;
        justify-content: space-between;
      }

      .hud-momentum {
        width: 100%;
        max-width: none;
      }

      .balance-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .balance-content {
        grid-template-columns: 1fr;
      }

      .radar-canvas {
        width: 100%;
        height: auto;
        max-width: 320px;
        margin: 0 auto;
      }

      .radar-legend {
        font-size: 0.6rem;
      }
    }

    /* Mobile-optimized pillar view */
    @media (max-width: 768px) {
      body {
        padding: 0;
        overflow-x: hidden;
      }

      .header-container {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
        padding: 12px 16px;
        width: calc(100% - 32px);
      }

      h1 {
        font-size: 1.3rem;
        white-space: nowrap;
      }

      .meta {
        text-align: left;
        font-size: 0.75rem;
      }

      /* Hide settings button on mobile */
      .settings-btn {
        display: none;
      }

      .grid-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 0;
        border: none;
        border-radius: 0;
        max-width: 100%;
        width: 100%;
        aspect-ratio: auto;
        height: auto;
        scroll-snap-type: y mandatory;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      /* Hide swipe hint */
      .grid-wrapper::after {
        display: none;
      }

      .pillar-box, .center-box {
        scroll-snap-align: start;
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding: 16px;
        border-bottom: 2px solid #d2d2d7;
        aspect-ratio: auto;
        width: 100%;
        min-height: auto;
        box-sizing: border-box;
      }

      .pillar-box:last-of-type {
        border-bottom: none;
      }

      /* Pillar-specific colored borders for visual distinction */
      .pillar-box:nth-child(1) { border-left: 4px solid #a8c5ff; }
      .pillar-box:nth-child(2) { border-left: 4px solid #c5b8ff; }
      .pillar-box:nth-child(3) { border-left: 4px solid #90d4a8; }
      .pillar-box:nth-child(4) { border-left: 4px solid #b8bac7; }
      .pillar-box:nth-child(5) { border-left: 4px solid #7dd4ca; }
      .pillar-box:nth-child(6) { border-left: 4px solid #ffd966; }
      .pillar-box:nth-child(7) { border-left: 4px solid #ffa8b8; }
      .pillar-box:nth-child(8) { border-left: 4px solid #ffb366; }

      .center-box {
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
        border-bottom: 2px solid #d2d2d7;
        border-left: none;
        padding: 24px 16px;
      }

      /* Keep tasks in 3x3 grid but make it responsive */
      .tasks-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 6px;
        width: 100%;
        max-width: 100%;
        margin: 0;
        box-sizing: border-box;
      }

      /* Position task cells, skipping the center for pillar title */
      .task-cell:nth-child(1) { grid-column: 1; grid-row: 1; }
      .task-cell:nth-child(2) { grid-column: 2; grid-row: 1; }
      .task-cell:nth-child(3) { grid-column: 3; grid-row: 1; }
      .task-cell:nth-child(4) { grid-column: 1; grid-row: 2; }
      .task-cell:nth-child(5) { grid-column: 3; grid-row: 2; }
      .task-cell:nth-child(6) { grid-column: 1; grid-row: 3; }
      .task-cell:nth-child(7) { grid-column: 2; grid-row: 3; }
      .task-cell:nth-child(8) { grid-column: 3; grid-row: 3; }

      .task-cell {
        min-height: unset;
        aspect-ratio: 1 / 1;
        font-size: 0.65rem;
        padding: 6px 4px;
        border-width: 1px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2px;
      }

      .task-title {
        font-size: 0.65rem;
        line-height: 1.1;
      }

      .task-hint {
        font-size: 0.55rem;
        line-height: 1.1;
      }

      /* Position pillar title in center of 3x3 grid */
      .pillar-title {
        font-size: 1rem;
        font-weight: 600;
        padding: 10px 6px;
        margin: 0;
        position: relative;
        grid-column: 2;
        grid-row: 2;
        aspect-ratio: 1 / 1;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        line-height: 1.2;
        word-wrap: break-word;
        hyphens: auto;
        overflow: auto;
      }

      .center-title {
        font-size: 1rem;
        padding: 16px 12px;
        aspect-ratio: auto;
        position: static;
        grid-column: auto;
        grid-row: auto;
        text-align: center;
        max-width: 400px;
      }

      .center-title strong {
        font-size: 0.9rem;
      }

      .center-title span {
        font-size: 0.9rem;
      }

      .pillar-card {
        font-size: 0.8rem;
        padding: 12px;
        min-height: 50px;
      }

      /* Adjust sections for mobile scroll */
      .growth-insights-section,
      .stats,
      .pillar-balance,
      .achievements-section {
        scroll-snap-align: start;
        min-height: auto;
        padding: 16px;
      }

      .achievements-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
      }

      .time-range-selector {
        flex-wrap: wrap;
        gap: 6px;
      }

      .time-range-btn {
        font-size: 0.7rem;
        padding: 6px 10px;
      }

      /* Better spacing for stats on mobile */
      .stats {
        margin-bottom: 0;
      }

      table {
        font-size: 0.7rem;
      }

      th, td {
        padding: 6px 4px;
      }
    }

    /* Extra small phones */
    @media (max-width: 375px) {
      .pillar-box {
        padding: 16px;
      }

      .task-cell {
        min-height: 55px;
        font-size: 0.85rem;
        padding: 12px;
      }

      .task-title {
        font-size: 0.85rem;
      }

      .task-hint {
        font-size: 0.72rem;
      }

      .pillar-title {
        font-size: 1.1rem;
        padding: 12px;
      }

      .achievements-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 6px;
      }

      .badge-card {
        padding: 6px;
      }

      .badge-icon {
        font-size: 1.2rem;
      }

      .badge-name {
        font-size: 0.7rem;
      }

      .badge-description {
        font-size: 0.6rem;
      }
    }

    /* Tablet landscape */
    @media (min-width: 769px) and (max-width: 1024px) {
      .grid-wrapper {
        max-width: 100%;
      }

      .balance-content {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .radar-canvas {
        margin: 0 auto;
      }
    }
  </style>
</head>
<body>
  <div class="header-container">
    <h1>Harada Open Window 64</h1>
    <div class="meta" id="dateDisplay"></div>
  </div>

  <div class="grid-wrapper" id="gridWrapper">
    <!-- Pillars & center will be injected here by JavaScript -->
  </div>

  <div class="today-reflection">
    <div class="reflection-count" id="reflectionCount">‚Äî</div>
    <div class="pillar-dots" id="pillarDots">
      <div class="pillar-dot" data-pillar="P1"></div>
      <div class="pillar-dot" data-pillar="P2"></div>
      <div class="pillar-dot" data-pillar="P3"></div>
      <div class="pillar-dot" data-pillar="P4"></div>
      <div class="pillar-dot" data-pillar="P5"></div>
      <div class="pillar-dot" data-pillar="P6"></div>
      <div class="pillar-dot" data-pillar="P7"></div>
      <div class="pillar-dot" data-pillar="P8"></div>
    </div>
    <div class="reflection-insight" id="reflectionInsight">Loading...</div>
  </div>

  <div class="growth-insights-section" style="display: none;">
    <h2>Your Growth</h2>
    <div class="growth-insights-content" id="growthInsights">
      <!-- Insights will be injected here by JavaScript -->
    </div>
  </div>

  <div class="stats">
    <h2>Progress Overview</h2>
    <table>
      <thead>
        <tr>
          <th>Pillar</th>
          <th>Tasks Completed Today</th>
          <th>Total Completions (All Time)</th>
        </tr>
      </thead>
      <tbody id="statsBody"></tbody>
    </table>
    <div class="stats-summary" id="statsSummary"></div>
  </div>

  <div class="pillar-balance">
    <div class="balance-header">
      <h2>Balance Over Time</h2>
      <div class="time-range-selector">
        <button class="time-range-btn" data-range="7">Last 7 days</button>
        <button class="time-range-btn active" data-range="30">Last 30 days</button>
        <button class="time-range-btn" data-range="90">Last 90 days</button>
        <button class="time-range-btn" data-range="ytd">YTD</button>
        <button class="time-range-btn" data-range="all">All Time</button>
      </div>
    </div>
    <div class="activity-timeline" id="activityTimeline">
      <div class="timeline-header">Daily Activity</div>
      <div class="timeline-chart" id="timelineChart"></div>
      <div class="timeline-labels" id="timelineLabels"></div>
    </div>
    <div class="balance-content">
      <div class="radar-section" style="position: relative;">
        <canvas id="radarChart" class="radar-canvas" width="320" height="320"></canvas>
        <div id="radarTooltip" class="radar-tooltip">
          <div class="radar-tooltip-pillar"></div>
          <div class="radar-tooltip-value"></div>
        </div>
        <div class="radar-legend">
          <div class="radar-legend-item"><span class="radar-legend-label">P1</span><span>Skill & Craft Mastery</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P2</span><span>Technical Building</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P3</span><span>Career Transition</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P4</span><span>Connection & Presence</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P5</span><span>Learning & Growth</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P6</span><span>Creative Platform</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P7</span><span>Health & Energy</span></div>
          <div class="radar-legend-item"><span class="radar-legend-label">P8</span><span>Identity & Discipline</span></div>
        </div>
      </div>
      <div class="balance-insights">
        <div class="insight-card">
          <div class="insight-label">
            Balance Score
            <span class="info-icon">
              i
              <span class="info-tooltip">Measures how evenly your effort is distributed across all 8 pillars. Higher scores (80-100) indicate balanced focus, while lower scores suggest concentration in fewer areas.</span>
            </span>
          </div>
          <div class="insight-value" id="balanceScore">‚Äî</div>
          <div class="insight-description" id="balanceDescription">Loading...</div>
        </div>
        <div class="insight-card">
          <div class="insight-label">
            Balance Trend
            <span class="info-icon">
              i
              <span class="info-tooltip">Compares your current balance score to the previous equivalent period. Positive values indicate improvement in distributing focus across pillars.</span>
            </span>
          </div>
          <div class="insight-value" id="balanceTrend">‚Äî</div>
          <div class="insight-description" id="balanceTrendDescription">Loading...</div>
        </div>
        <div class="insight-card overweighted-pillar" id="focusPatternCard">
          <div class="insight-label">
            Focus Pattern
            <span class="info-icon">
              i
              <span class="info-tooltip">Shows where your attention is concentrated and which areas might benefit from more focus.</span>
            </span>
          </div>
          <div class="insight-value" id="focusPatternPrimary">‚Äî</div>
          <div class="insight-description" id="focusPatternDescription">Loading...</div>
          <div class="insight-secondary" id="focusPatternSecondary"></div>
        </div>
        <div class="insight-card stability-card">
          <div class="insight-label">
            Focus Stability
            <span class="info-icon">
              i
              <span class="info-tooltip">Measures consistency of your pillar focus from day to day (0-10 scale). Steady patterns (8-10) show reliable attention. Dynamic patterns (0-4) reflect frequent shifts.</span>
            </span>
          </div>
          <div class="insight-value" id="stabilityScore">‚Äî</div>
          <div class="insight-description" id="stabilityDescription">Loading...</div>
        </div>
        <div class="balance-footer" id="balanceFooter">Loading balance insights...</div>
      </div>
    </div>
  </div>

  <!-- New Analytics Sections -->
  <div class="analytics-section" id="priorityAlignmentSection">
    <h2>üéØ Priority Alignment</h2>
    <div class="priority-grid" id="priorityGrid">
      <!-- Priority rows will be injected here -->
    </div>
  </div>

  <div class="analytics-section" id="streaksSection" style="display: none;">
    <h2>üî• Streaks & Momentum</h2>
    <div class="streaks-grid" id="streaksGrid">
      <!-- Streak cards will be injected here -->
    </div>
    <div id="atRiskContainer"></div>
    <div id="momentumSummary" style="margin-top: 12px; padding: 12px; background: #f9fafb; border-radius: 8px; font-size: 0.8rem; color: #1d1d1f;"></div>
  </div>

  <div class="analytics-section" id="recommendationsSection">
    <h2>üìã Today's Focus Recommendations</h2>
    <div class="recommendations-list" id="recommendationsList">
      <!-- Recommendations will be injected here -->
    </div>
  </div>

  <div class="analytics-section" id="weeklySummarySection">
    <h2>üìä This Week's Summary</h2>
    <div class="summary-section">
      <h3>üéâ Wins</h3>
      <div class="summary-items" id="weeklySummaryWins"></div>
    </div>
    <div class="summary-section">
      <h3>‚ö†Ô∏è Gaps to Address</h3>
      <div class="summary-items" id="weeklySummaryGaps"></div>
    </div>
    <div class="summary-section">
      <h3>üìà Week Over Week</h3>
      <div class="summary-items" id="weeklySummaryTrends"></div>
    </div>
  </div>

  <div class="analytics-section" id="goalProgressSection" style="display: none;">
    <h2>üéØ Goal Progress: $150K Role + Launch Art Income</h2>
    <h3>Career Transition</h3>
    <div class="metrics-grid" id="careerMetricsGrid"></div>
    <h3 style="margin-top: 16px;">Creative Platform</h3>
    <div class="metrics-grid" id="creativeMetricsGrid"></div>
    <div id="timeToGoal" style="margin-top: 16px; padding: 12px; background: #f0f9ff; border: 1px solid #007aff; border-radius: 8px; font-size: 0.8rem; color: #1d1d1f;"></div>
  </div>

  <div class="achievements-section">
    <h2 style="cursor: pointer; display: flex; align-items: center; justify-content: space-between; user-select: none;" id="achievementsToggle">
      <span>Achievements</span>
      <span id="achievementsArrow" style="transition: transform 0.2s ease;">‚ñº</span>
    </h2>
    <div class="achievements-grid" id="achievementsGrid" style="display: none;">
      <!-- Badges will be injected here by JavaScript -->
    </div>
  </div>

  <!-- Settings Button & Overlay -->
  <button class="settings-btn" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-panel">
      <div class="settings-header">
        <h2>Settings</h2>
        <button class="settings-close" id="settingsClose">√ó</button>
      </div>
      
      <div class="settings-group">
        <h3>Pillar Target Percentages</h3>
        <p style="font-size: 0.75rem; color: #6e6e73; margin: 0 0 12px 0;">Set your ideal distribution of effort across pillars (must total 100%)</p>
        <div id="pillarTargetsSettings"></div>
      </div>

      <div class="settings-group">
        <h3>Goal Relevance Weights</h3>
        <p style="font-size: 0.75rem; color: #6e6e73; margin: 0 0 12px 0;">Rate how relevant each pillar is to your main goal (1-10 scale)</p>
        <div id="goalWeightsSettings"></div>
      </div>

      <div class="settings-group">
        <h3>Time Budget</h3>
        <div class="settings-row">
          <span class="settings-label">Work Hours Per Week</span>
          <input type="number" class="settings-input" id="workHoursInput" min="0" max="80" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Available Hours Per Day</span>
          <input type="number" class="settings-input" id="availableHoursInput" min="0" max="12" step="0.5" />
        </div>
      </div>

      <div class="settings-group">
        <h3>Goal Metrics</h3>
        <div class="settings-row">
          <span class="settings-label">Jobs Applied (Total)</span>
          <input type="number" class="settings-input" id="jobsAppliedInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Interviews Scheduled</span>
          <input type="number" class="settings-input" id="interviewsInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Networking Conversations</span>
          <input type="number" class="settings-input" id="networkingInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">LinkedIn Connections</span>
          <input type="number" class="settings-input" id="linkedinInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Instagram Followers</span>
          <input type="number" class="settings-input" id="instagramInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">TikTok Followers</span>
          <input type="number" class="settings-input" id="tiktokInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Posts This Week</span>
          <input type="number" class="settings-input" id="postsInput" min="0" />
        </div>
        <div class="settings-row">
          <span class="settings-label">Art Revenue ($)</span>
          <input type="number" class="settings-input" id="revenueInput" min="0" step="0.01" />
        </div>
      </div>

      <button class="settings-save-btn" id="settingsSaveBtn">Save Settings</button>
    </div>
  </div>

  <div class="achievements-section" style="display:none;">
    <h2>Achievements</h2>
    <div class="achievements-grid" id="achievementsGrid">
      <!-- Badges will be injected here by JavaScript -->
    </div>
  </div>

  <script>
    // Pillar color map
    const pillarColors = {
      'P1': '#E8F0FE', // Soft Blue
      'P2': '#F1ECFF', // Soft Violet
      'P3': '#EAF7EF', // Soft Green
      'P4': '#E6F6F4', // Soft Teal
      'P5': '#FFF1E6', // Soft Peach
      'P6': '#FDECEF', // Soft Pink
      'P7': '#FFF8E1', // Soft Yellow
      'P8': '#F2F3F7'  // Soft Gray-Lavender
    };

    const pillars = [
      {
        id: "P1",
        name: "Skill & Craft Mastery",
        tasks: [
          { title: "Sketch", hint: "New idea or concept" },
          { title: "Study", hint: "Form (anatomy/perspective/composition)" },
          { title: "Simplify", hint: "Reference into simple shapes" },
          { title: "Practice", hint: "Gesture drawing for 15 min" },
          { title: "Work", hint: "On current piece/idea" },
          { title: "Capture", hint: "One new idea in notes" },
          { title: "Observe", hint: "Analyze reference images" },
          { title: "Control", hint: "Edges in current artwork" }
        ]
      },
      {
        id: "P2",
        name: "Technical Building",
        tasks: [
          { title: "Write", hint: "Code for personal project" },
          { title: "Build", hint: "One new feature" },
          { title: "Fix", hint: "Bug in current project" },
          { title: "Refactor", hint: "Existing code" },
          { title: "Test", hint: "App flow or functionality" },
          { title: "Build Tool", hint: "That solves a problem" },
          { title: "Learn by", hint: "Implementing (tutorial/example)" },
          { title: "Apply", hint: "New technique to project" }
        ]
      },
      {
        id: "P3",
        name: "Finance",
        tasks: [
          { title: "Apply", hint: "To 1-2 target roles" },
          { title: "Research", hint: "Companies/roles for applications" },
          { title: "Reach Out", hint: "1 person at target company" },
          { title: "Practice", hint: "Answering interview questions" },
          { title: "Save", hint: "Money or budget" },
          { title: "Learn", hint: "One career-relevant skill" },
          { title: "Invest", hint: "In stocks, funds, or education" },
          { title: "Bookmark", hint: "One role or opportunity" }
        ]
      },
      {
        id: "P4",
        name: "Connection & Presence",
        tasks: [
          { title: "Reach Out", hint: "To one person (text/DM)" },
          { title: "Say Yes", hint: "To an invitation" },
          { title: "Plan", hint: "A hangout or suggest plans" },
          { title: "Show Up", hint: "To chess meetup or social event" },
          { title: "Be", hint: "Mindful (no multitasking)" },
          { title: "Engage", hint: "In online community genuinely" },
          { title: "Follow Up", hint: "With someone you haven't talked to" },
          { title: "Plan Date", hint: "Or activity with girlfriend" }
        ]
      },
      {
        id: "P5",
        name: "Learning & Growth",
        tasks: [
          { title: "Read", hint: "About topic you're curious about" },
          { title: "Watch", hint: "Documentary or educational content" },
          { title: "Take", hint: "Online course in career-relevant skill" },
          { title: "Listen", hint: "To podcast in your field" },
          { title: "Learn From", hint: "Someone you admire" },
          { title: "Consume", hint: "Content that inspires you" },
          { title: "Listen", hint: "To audiobook or lecture" },
          { title: "Explore", hint: "Adjacent skills" }
        ]
      },
      {
        id: "P6",
        name: "Creative Platform",
        tasks: [
          { title: "Create", hint: "Art (even 15-20 min)" },
          { title: "Publish", hint: "One piece of content" },
          { title: "Capture", hint: "Process or idea" },
          { title: "Share", hint: "Work-in-progress or process" },
          { title: "Write", hint: "Caption or content idea" },
          { title: "Edit", hint: "Media for posting" },
          { title: "Plan", hint: "Tomorrow's content" },
          { title: "Observe", hint: "What's working for creators" }
        ]
      },
      {
        id: "P7",
        name: "Health & Energy",
        tasks: [
          { title: "Train", hint: "Go to gym/workout" },
          { title: "Eat", hint: "Enough (hit calorie target)" },
          { title: "Sleep", hint: "8 hours" },
          { title: "Stretch", hint: "Posture & hips" },
          { title: "Drink", hint: "Water (hit daily target)" },
          { title: "Take", hint: "Supplements" },
          { title: "Recover", hint: "Active rest or full rest day" },
          { title: "Meal Prep", hint: "For tomorrow" }
        ]
      },
      {
        id: "P8",
        name: "Identity & Discipline",
        tasks: [
          { title: "Shut Down", hint: "Phone/laptop when arriving home" },
          { title: "Keep", hint: "Environment clean and organized" },
          { title: "Decide", hint: "Today's #1 priority (morning)" },
          { title: "Start", hint: "Hard thing first (no warm-up)" },
          { title: "Keep", hint: "Promise to yourself today" },
          { title: "Regain", hint: "Attention when distracted" },
          { title: "Be", hint: "Present (no multitasking)" },
          { title: "Treat Others", hint: "How you want to be treated" }
        ]
      }
    ];

    const STORAGE_TODAY_KEY = "haradaTodayState";
    const STORAGE_STATS_KEY = "haradaStatsAllTime";
    const STORAGE_HISTORY_KEY = "haradaHistory";
    const STORAGE_STREAKS_KEY = "haradaStreaks";
    const STORAGE_BADGES_KEY = "haradaBadges";
    const STORAGE_SETTINGS_KEY = "haradaSettings";
    const STORAGE_PILLAR_STREAKS_KEY = "haradaPillarStreaks";
    const STORAGE_GOAL_METRICS_KEY = "haradaGoalMetrics";
    const MIN_TASKS_FOR_STREAK = 1; // Configurable threshold

    // Default settings for new analytics
    const DEFAULT_SETTINGS = {
      pillarTargets: {
        P1: 5,   // Skill & Craft Mastery
        P2: 10,  // Technical Building
        P3: 45,  // Career Transition - Primary Goal!
        P4: 8,   // Connection & Presence
        P5: 5,   // Learning & Growth
        P6: 10,  // Creative Platform
        P7: 12,  // Health & Energy
        P8: 15   // Identity & Discipline
      },
      goalWeights: {
        P1: 6,   // Skill & Craft Mastery
        P2: 4,   // Technical Building
        P3: 10,  // Career Transition - Most relevant!
        P4: 5,   // Connection & Presence
        P5: 5,   // Learning & Growth
        P6: 6,   // Creative Platform
        P7: 7,   // Health & Energy
        P8: 8    // Identity & Discipline
      },
      availableHoursPerDay: 3,
      workHoursPerWeek: 45
    };

    // Badge definitions
    const BADGES = [
      // First Steps & Milestones
      {
        id: 'first-step',
        name: 'First Step',
        icon: 'üå±',
        description: 'Complete your first task',
        check: (data) => data.totalAllTime >= 1
      },
      {
        id: 'getting-started',
        name: 'Getting Started',
        icon: 'üéØ',
        description: 'Complete 10 total tasks',
        check: (data) => data.totalAllTime >= 10
      },
      {
        id: 'quarter-century',
        name: 'Quarter Century',
        icon: 'üéä',
        description: 'Complete 25 total tasks',
        check: (data) => data.totalAllTime >= 25
      },
      {
        id: 'half-century',
        name: 'Half Century',
        icon: 'üéâ',
        description: 'Complete 50 total tasks',
        check: (data) => data.totalAllTime >= 50
      },
      {
        id: 'century-club',
        name: 'Century Club',
        icon: 'üíØ',
        description: 'Complete 100 total tasks',
        check: (data) => data.totalAllTime >= 100
      },
      {
        id: 'double-century',
        name: 'Double Century',
        icon: 'üéñÔ∏è',
        description: 'Complete 200 total tasks',
        check: (data) => data.totalAllTime >= 200
      },
      {
        id: 'five-hundred-club',
        name: 'Five Hundred Club',
        icon: 'üíé',
        description: 'Complete 500 total tasks',
        check: (data) => data.totalAllTime >= 500
      },
      {
        id: 'thousand-strong',
        name: 'Thousand Strong',
        icon: 'üèîÔ∏è',
        description: 'Complete 1000 total tasks',
        check: (data) => data.totalAllTime >= 1000
      },
      
      // Streak Achievements
      {
        id: 'starter-streak',
        name: 'Starter Streak',
        icon: 'üåü',
        description: 'Maintain a 3-day streak',
        check: (data) => data.currentStreak >= 3
      },
      {
        id: 'week-warrior',
        name: 'Week Warrior',
        icon: 'üî•',
        description: 'Maintain a 7-day streak',
        check: (data) => data.currentStreak >= 7
      },
      {
        id: 'two-week-titan',
        name: 'Two Week Titan',
        icon: '‚öîÔ∏è',
        description: 'Maintain a 14-day streak',
        check: (data) => data.currentStreak >= 14
      },
      {
        id: 'month-master',
        name: 'Month Master',
        icon: '‚ö°',
        description: 'Maintain a 30-day streak',
        check: (data) => data.currentStreak >= 30
      },
      {
        id: 'century-streak',
        name: 'Century Streak',
        icon: 'üèõÔ∏è',
        description: 'Maintain a 100-day streak',
        check: (data) => data.currentStreak >= 100
      },
      {
        id: 'unstoppable',
        name: 'Unstoppable',
        icon: 'üöÄ',
        description: 'Maintain a 365-day streak',
        check: (data) => data.currentStreak >= 365
      },
      
      // Daily Intensity
      {
        id: 'power-hour',
        name: 'Power Hour',
        icon: '‚ö°',
        description: 'Complete 10 tasks in one day',
        check: (data) => data.totalToday >= 10
      },
      {
        id: 'beast-mode',
        name: 'Beast Mode',
        icon: 'ü¶Å',
        description: 'Complete 15 tasks in one day',
        check: (data) => data.totalToday >= 15
      },
      {
        id: 'legendary-day',
        name: 'Legendary Day',
        icon: 'üëë',
        description: 'Complete 20+ tasks in one day',
        check: (data) => data.totalToday >= 20
      },
      {
        id: 'four-corners',
        name: 'Four Corners',
        icon: 'üéØ',
        description: 'Complete all 8 tasks in 4 different pillars in one day',
        check: (data) => data.fullPillarsToday >= 4
      },
      
      // Balance & Variety
      {
        id: 'perfect-day',
        name: 'Perfect Day',
        icon: '‚ú®',
        description: 'Touch all 8 pillars in one day',
        check: (data) => data.pillarsToday >= 8
      },
      {
        id: 'balanced-builder',
        name: 'Balanced Builder',
        icon: '‚öñÔ∏è',
        description: 'Achieve 80+ balance score',
        check: (data) => data.balanceScore >= 80
      },
      {
        id: 'equilibrium',
        name: 'Equilibrium',
        icon: 'üî∑',
        description: 'Achieve 90+ balance score',
        check: (data) => data.balanceScore >= 90
      },
      {
        id: 'harmony-master',
        name: 'Harmony Master',
        icon: '‚ú®',
        description: 'Achieve 95+ balance score',
        check: (data) => data.balanceScore >= 95
      },
      {
        id: 'consistent-breadth',
        name: 'Consistent Breadth',
        icon: 'üåà',
        description: 'Touch all 8 pillars 3 days in a row',
        check: (data) => data.allPillarsThreeDays
      },
      
      // Pillar Mastery
      {
        id: 'deep-diver',
        name: 'Deep Diver',
        icon: 'üéØ',
        description: 'Complete all 8 tasks in a single pillar in one day',
        check: (data) => data.pillarCompleteToday
      },
      {
        id: 'pillar-apprentice',
        name: 'Pillar Apprentice',
        icon: 'üìö',
        description: 'Complete 25 total tasks in any single pillar',
        check: (data) => data.maxPillarTotal >= 25
      },
      {
        id: 'pillar-expert',
        name: 'Pillar Expert',
        icon: 'üéì',
        description: 'Complete 50 total tasks in any single pillar',
        check: (data) => data.maxPillarTotal >= 50
      },
      {
        id: 'pillar-master',
        name: 'Pillar Master',
        icon: 'üèÜ',
        description: 'Complete 100 total tasks in any single pillar',
        check: (data) => data.maxPillarTotal >= 100
      },
      {
        id: 'renaissance-builder',
        name: 'Renaissance Builder',
        icon: 'üé®',
        description: 'Complete 50+ tasks in 3 different pillars',
        check: (data) => data.pillarsOver50 >= 3
      },
      
      // Special Combinations
      {
        id: 'mind-and-body',
        name: 'Mind & Body',
        icon: 'üß†üí™',
        description: 'Complete Health + Identity on same day, 5 times',
        check: (data) => data.mindBodyCount >= 5
      },
      {
        id: 'builders-trifecta',
        name: "Builder's Trifecta",
        icon: 'üõ†Ô∏è',
        description: 'Complete Technical Building, Career Transition, and Connection on same day',
        check: (data) => data.buildersTrifectaToday
      },
      {
        id: 'creators-flow',
        name: "Creator's Flow",
        icon: 'üé®',
        description: 'Complete Skill & Craft, Creative Platform, and Learning pillars on same day',
        check: (data) => data.creatorsFlowToday
      }
    ];

    function getTodayString() {
      const d = new Date();
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function formatPrettyDate() {
      const d = new Date();
      return d.toLocaleDateString(undefined, {
        weekday: "long",
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    let todayState = null;
    let statsAllTime = null;
    let dailyHistory = null;
    let streakData = null;
    let badgesData = null;
    let selectedTimeRange = "30";
    let userSettings = null;
    let pillarStreaks = null;
    let goalMetrics = null;

    function loadState() {
      const today = getTodayString();
      const rawToday = localStorage.getItem(STORAGE_TODAY_KEY);
      const rawStats = localStorage.getItem(STORAGE_STATS_KEY);
      const rawHistory = localStorage.getItem(STORAGE_HISTORY_KEY);
      const rawStreaks = localStorage.getItem(STORAGE_STREAKS_KEY);

      try {
        todayState = rawToday ? JSON.parse(rawToday) : null;
      } catch {
        todayState = null;
      }
      if (!todayState || todayState.date !== today) {
        // Save yesterday's count and pillar breakdown before resetting
        if (todayState && todayState.date) {
          const yesterdayPillarTotals = {};
          pillars.forEach(p => yesterdayPillarTotals[p.id] = 0);
          
          Object.keys(todayState.completed).forEach(cellId => {
            const pillarId = cellId.split('-')[0];
            if (yesterdayPillarTotals[pillarId] !== undefined) {
              yesterdayPillarTotals[pillarId]++;
            }
          });
          
          const yesterdayCount = Object.keys(todayState.completed).length;
          
          if (dailyHistory) {
            dailyHistory[todayState.date] = {
              total: yesterdayCount,
              pillars: yesterdayPillarTotals
            };
            localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));
          }
        }
        todayState = { date: today, completed: {} };
        localStorage.setItem(STORAGE_TODAY_KEY, JSON.stringify(todayState));
      }

      try {
        statsAllTime = rawStats ? JSON.parse(rawStats) : null;
      } catch {
        statsAllTime = null;
      }
      if (!statsAllTime) {
        statsAllTime = {};
        localStorage.setItem(STORAGE_STATS_KEY, JSON.stringify(statsAllTime));
      }

      try {
        dailyHistory = rawHistory ? JSON.parse(rawHistory) : {};
      } catch {
        dailyHistory = {};
      }
      
      // Migrate old format to new format
      Object.keys(dailyHistory).forEach(date => {
        const entry = dailyHistory[date];
        // If entry is just a number (old format), convert to new format
        if (typeof entry === 'number') {
          dailyHistory[date] = {
            total: entry,
            pillars: {} // No pillar breakdown available for old data
          };
        }
      });
      
      localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));

      try {
        streakData = rawStreaks ? JSON.parse(rawStreaks) : null;
      } catch {
        streakData = null;
      }
      if (!streakData) {
        streakData = { current: 0, best: 0 };
        localStorage.setItem(STORAGE_STREAKS_KEY, JSON.stringify(streakData));
      }

      try {
        const rawBadges = localStorage.getItem(STORAGE_BADGES_KEY);
        badgesData = rawBadges ? JSON.parse(rawBadges) : {};
      } catch {
        badgesData = {};
      }
      localStorage.setItem(STORAGE_BADGES_KEY, JSON.stringify(badgesData));

      // Load user settings
      try {
        const rawSettings = localStorage.getItem(STORAGE_SETTINGS_KEY);
        userSettings = rawSettings ? JSON.parse(rawSettings) : null;
      } catch {
        userSettings = null;
      }
      if (!userSettings) {
        userSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS)); // Deep clone
        localStorage.setItem(STORAGE_SETTINGS_KEY, JSON.stringify(userSettings));
      }

      // Load pillar streaks
      try {
        const rawPillarStreaks = localStorage.getItem(STORAGE_PILLAR_STREAKS_KEY);
        pillarStreaks = rawPillarStreaks ? JSON.parse(rawPillarStreaks) : null;
      } catch {
        pillarStreaks = null;
      }
      if (!pillarStreaks) {
        pillarStreaks = {};
        pillars.forEach(p => {
          pillarStreaks[p.id] = { current: 0, best: 0, lastActive: null };
        });
        localStorage.setItem(STORAGE_PILLAR_STREAKS_KEY, JSON.stringify(pillarStreaks));
      }

      // Load goal metrics
      try {
        const rawGoalMetrics = localStorage.getItem(STORAGE_GOAL_METRICS_KEY);
        goalMetrics = rawGoalMetrics ? JSON.parse(rawGoalMetrics) : null;
      } catch {
        goalMetrics = null;
      }
      if (!goalMetrics) {
        goalMetrics = {
          jobsApplied: 0,
          interviewsScheduled: 0,
          networkingConversations: 0,
          linkedinConnections: 0,
          instagramFollowers: 0,
          tiktokFollowers: 0,
          postsThisWeek: 0,
          artRevenue: 0,
          history: [] // { date, metric, value }
        };
        localStorage.setItem(STORAGE_GOAL_METRICS_KEY, JSON.stringify(goalMetrics));
      }
    }

    function saveTodayState() {
      localStorage.setItem(STORAGE_TODAY_KEY, JSON.stringify(todayState));
    }

    function saveStats() {
      localStorage.setItem(STORAGE_STATS_KEY, JSON.stringify(statsAllTime));
    }

    function calculateStreaks() {
      const today = getTodayString();
      const todayCount = Object.keys(todayState.completed).length;
      
      // Calculate today's pillar breakdown
      const todayPillarTotals = {};
      pillars.forEach(p => todayPillarTotals[p.id] = 0);
      
      Object.keys(todayState.completed).forEach(cellId => {
        const pillarId = cellId.split('-')[0];
        if (todayPillarTotals[pillarId] !== undefined) {
          todayPillarTotals[pillarId]++;
        }
      });
      
      // Update today in history with new format
      dailyHistory[today] = {
        total: todayCount,
        pillars: todayPillarTotals
      };
      localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(dailyHistory));

      // Get all dates sorted descending
      const allDates = Object.keys(dailyHistory).sort().reverse();
      
      // Calculate current streak
      let currentStreak = 0;
      const dateIterator = new Date();
      
      while (true) {
        const dateStr = dateIterator.toISOString().split('T')[0];
        const entry = dailyHistory[dateStr];
        const count = entry ? (entry.total || entry) : 0;
        
        if (count >= MIN_TASKS_FOR_STREAK) {
          currentStreak++;
        } else {
          break;
        }
        
        // Move to previous day
        dateIterator.setDate(dateIterator.getDate() - 1);
        
        // Safety: don't go back more than 365 days
        if (currentStreak > 365) break;
      }

      // Calculate best streak
      let bestStreak = 0;
      let tempStreak = 0;
      let previousDate = null;
      
      for (const dateStr of allDates) {
        const entry = dailyHistory[dateStr];
        const count = entry ? (entry.total || entry) : 0;
        const currentDate = new Date(dateStr);
        
        if (count >= MIN_TASKS_FOR_STREAK) {
          if (previousDate === null) {
            tempStreak = 1;
          } else {
            const dayDiff = Math.floor((previousDate - currentDate) / (1000 * 60 * 60 * 24));
            if (dayDiff === 1) {
              tempStreak++;
            } else {
              bestStreak = Math.max(bestStreak, tempStreak);
              tempStreak = 1;
            }
          }
        } else {
          bestStreak = Math.max(bestStreak, tempStreak);
          tempStreak = 0;
        }
        
        previousDate = currentDate;
      }
      bestStreak = Math.max(bestStreak, tempStreak);

      streakData.current = currentStreak;
      streakData.best = Math.max(streakData.best, bestStreak);
      localStorage.setItem(STORAGE_STREAKS_KEY, JSON.stringify(streakData));
    }

    function getLast7Days() {
      const days = [];
      const today = new Date();
      
      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        const dayName = date.toLocaleDateString(undefined, { weekday: 'short' });
        const entry = dailyHistory[dateStr];
        const count = entry ? (entry.total || entry) : 0;
        const isToday = dateStr === getTodayString();
        days.push({ date: dateStr, dayName, count, isToday });
      }
      
      return days;
    }

    function updateStreakUI() {
      calculateStreaks();

      const currentStreakEl = document.getElementById('currentStreak');
      const bestStreakEl = document.getElementById('bestStreak');
      
      if (currentStreakEl) currentStreakEl.textContent = streakData.current;
      if (bestStreakEl) bestStreakEl.textContent = streakData.best;
      
      // Render mini momentum bars
      const last7 = getLast7Days();
      const chart = document.getElementById('momentumChart');
      if (!chart) return;
      chart.innerHTML = '';
      
      const maxCount = Math.max(...last7.map(d => d.count), 8);
      
      last7.forEach(day => {
        const bar = document.createElement('div');
        bar.className = 'momentum-mini-bar';
        
        if (day.count > 0) {
          bar.classList.add('has-data');
        }
        if (day.isToday) {
          bar.classList.add('today');
        }
        
        const heightPercent = day.count > 0 ? Math.max((day.count / maxCount) * 100, 8) : 8;
        bar.style.height = `${heightPercent}%`;
        bar.title = `${day.dayName}: ${day.count} tasks`;
        
        chart.appendChild(bar);
      });
    }

    function createPillarBox(pillar) {
      const box = document.createElement("div");
      box.className = "pillar-box";

      const tasksGrid = document.createElement("div");
      tasksGrid.className = "tasks-grid";

      const title = document.createElement("div");
      title.className = "pillar-title";
      title.textContent = pillar.name;
      title.dataset.pillar = pillar.id;

      pillar.tasks.forEach((task, index) => {
        const cell = document.createElement("div");
        cell.className = "task-cell";
        const cellId = `${pillar.id}-T${index + 1}`;
        cell.dataset.id = cellId;
        cell.dataset.pillar = pillar.id;
        
        // Store full task text for tooltip
        cell.dataset.taskTitle = task.title;
        cell.dataset.taskHint = task.hint;
        
        const titleEl = document.createElement("div");
        titleEl.className = "task-title";
        titleEl.textContent = task.title;
        
        const hintEl = document.createElement("div");
        hintEl.className = "task-hint";
        hintEl.textContent = task.hint;
        
        cell.appendChild(titleEl);
        cell.appendChild(hintEl);

        if (todayState.completed[cellId]) {
          cell.classList.add("completed");
        }

        cell.addEventListener("click", () => {
          toggleTask(cell);
        });

        // Add tooltip event listeners
        cell.addEventListener("mouseenter", (e) => showTaskTooltip(e, cell));
        cell.addEventListener("mouseleave", hideTaskTooltip);
        cell.addEventListener("mousemove", updateTooltipPosition);
        
        // Mobile support: show tooltip on touch (tap and hold)
        let touchTimer;
        cell.addEventListener("touchstart", (e) => {
          touchTimer = setTimeout(() => {
            showTaskTooltip(e, cell);
          }, 300); // Show after 300ms hold
        });
        
        cell.addEventListener("touchend", () => {
          clearTimeout(touchTimer);
          // Don't hide immediately on touchend to allow reading
        });
        
        cell.addEventListener("touchmove", () => {
          clearTimeout(touchTimer);
          hideTaskTooltip();
        });

        tasksGrid.appendChild(cell);
      });

      tasksGrid.appendChild(title);
      box.appendChild(tasksGrid);
      return box;
    }

    // Tooltip helper functions
    let tooltipElement = null;
    let currentTooltipCell = null;
    let tooltipHideTimer = null;

    function showTaskTooltip(event, cell) {
      // Clear any pending hide timer
      if (tooltipHideTimer) {
        clearTimeout(tooltipHideTimer);
        tooltipHideTimer = null;
      }

      // Don't show tooltip if already showing for this cell
      if (currentTooltipCell === cell && tooltipElement && tooltipElement.classList.contains('visible')) {
        return;
      }

      currentTooltipCell = cell;
      const taskTitle = cell.dataset.taskTitle;
      const taskHint = cell.dataset.taskHint;

      // Only show tooltip if there's text to display
      if (!taskTitle && !taskHint) return;

      // Create tooltip element if it doesn't exist
      if (!tooltipElement) {
        tooltipElement = document.createElement('div');
        tooltipElement.className = 'task-tooltip';
        document.body.appendChild(tooltipElement);
      }

      // Set tooltip content
      let tooltipHTML = '';
      if (taskTitle) {
        tooltipHTML += `<div class="task-tooltip-title">${taskTitle}</div>`;
      }
      if (taskHint) {
        tooltipHTML += `<div class="task-tooltip-hint">${taskHint}</div>`;
      }
      tooltipElement.innerHTML = tooltipHTML;

      // Position and show tooltip
      positionTooltip(event);
      
      // Use requestAnimationFrame to ensure the tooltip is rendered before showing
      requestAnimationFrame(() => {
        if (tooltipElement) {
          tooltipElement.classList.add('visible');
        }
      });
    }

    function hideTaskTooltip() {
      // Delay hiding to allow for smooth transitions
      if (tooltipHideTimer) {
        clearTimeout(tooltipHideTimer);
      }
      
      tooltipHideTimer = setTimeout(() => {
        if (tooltipElement) {
          tooltipElement.classList.remove('visible');
        }
        currentTooltipCell = null;
      }, 100);
    }

    function updateTooltipPosition(event) {
      if (tooltipElement && tooltipElement.classList.contains('visible')) {
        positionTooltip(event);
      }
    }

    function positionTooltip(event) {
      if (!tooltipElement) return;

      // Get cursor position
      const cursorX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
      const cursorY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);

      // Get tooltip dimensions
      const tooltipRect = tooltipElement.getBoundingClientRect();
      const tooltipWidth = tooltipRect.width || 280;
      const tooltipHeight = tooltipRect.height;

      // Get viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Calculate position with offset from cursor
      const offsetX = 12;
      const offsetY = 12;
      let left = cursorX + offsetX;
      let top = cursorY + offsetY;

      // Adjust if tooltip goes off right edge
      if (left + tooltipWidth > viewportWidth - 10) {
        left = cursorX - tooltipWidth - offsetX;
      }

      // Adjust if tooltip goes off bottom edge
      if (top + tooltipHeight > viewportHeight - 10) {
        top = cursorY - tooltipHeight - offsetY;
      }

      // Ensure tooltip doesn't go off left edge
      if (left < 10) {
        left = 10;
      }

      // Ensure tooltip doesn't go off top edge
      if (top < 10) {
        top = 10;
      }

      tooltipElement.style.left = `${left}px`;
      tooltipElement.style.top = `${top}px`;
    }

    // Hide tooltip when clicking anywhere
    document.addEventListener('click', () => {
      hideTaskTooltip();
    });

    function createCenterBox() {
      const box = document.createElement("div");
      box.className = "center-box";

      const tasksGrid = document.createElement("div");
      tasksGrid.className = "tasks-grid";

      // Define explicit grid placement for each pillar
      const pillarLayout = [
        { pillar: pillars[0], row: 1, col: 1 }, // P1: Skill & Craft Mastery
        { pillar: pillars[1], row: 1, col: 2 }, // P2: Technical Building
        { pillar: pillars[2], row: 1, col: 3 }, // P3: Career Transition
        { pillar: pillars[7], row: 2, col: 1 }, // P8: Identity & Discipline
        { pillar: pillars[3], row: 2, col: 3 }, // P4: Connection & Presence
        { pillar: pillars[6], row: 3, col: 1 }, // P7: Health & Energy
        { pillar: pillars[5], row: 3, col: 2 }, // P6: Creative Platform
        { pillar: pillars[4], row: 3, col: 3 }  // P5: Learning & Growth
      ];

      // Create pillar cards with explicit positioning
      pillarLayout.forEach(({ pillar, row, col }) => {
        const pillarCard = document.createElement("div");
        pillarCard.className = "pillar-card";
        pillarCard.textContent = pillar.name;
        pillarCard.dataset.pillar = pillar.id;
        pillarCard.style.gridRow = row;
        pillarCard.style.gridColumn = col;
        tasksGrid.appendChild(pillarCard);
      });

      // Create center goal card (row 2, col 2)
      const centerTitle = document.createElement("div");
      centerTitle.className = "center-title";
      centerTitle.innerHTML = `
        <strong>Goal:</strong>
        <span>Level Up Career, Scale Creative Business</span>
      `;
      
      tasksGrid.appendChild(centerTitle);
      box.appendChild(tasksGrid);
      return box;
    }

    function renderGrid() {
      const gridWrapper = document.getElementById("gridWrapper");
      gridWrapper.innerHTML = "";

      const layoutOrder = ["P1", "P2", "P3", "P8", "CENTER", "P4", "P7", "P6", "P5"];

      layoutOrder.forEach((id) => {
        if (id === "CENTER") {
          gridWrapper.appendChild(createCenterBox());
        } else {
          const pillar = pillars.find((p) => p.id === id);
          gridWrapper.appendChild(createPillarBox(pillar));
        }
      });
    }

    function toggleTask(cell) {
      const cellId = cell.dataset.id;
      const isCompleted = !!todayState.completed[cellId];

      if (isCompleted) {
        delete todayState.completed[cellId];
        cell.classList.remove("completed");

        if (statsAllTime[cellId] && statsAllTime[cellId] > 0) {
          statsAllTime[cellId] -= 1;
        }
      } else {
        todayState.completed[cellId] = true;
        cell.classList.add("completed");
        statsAllTime[cellId] = (statsAllTime[cellId] || 0) + 1;
      }

      saveTodayState();
      saveStats();
      updateTodayReflection();
      updateStatsUI();
      updateStreakUI();
      updatePillarBalance();
      checkAndAwardBadges();
      updateNewAnalytics(); // Update new analytics sections

      // Check for pillar completion and trigger confetti
      if (!isCompleted) {
        checkPillarCompletion(cell.dataset.pillar);
      }
    }

    function checkPillarCompletion(pillarId) {
      // Count completed tasks for this pillar
      const pillarTasksCompleted = Object.keys(todayState.completed).filter(
        taskId => taskId.startsWith(pillarId + '-')
      ).length;

      // If all 8 tasks completed, trigger confetti
      if (pillarTasksCompleted === 8) {
        const pillar = pillars.find(p => p.id === pillarId);
        triggerPillarConfetti(pillar);
      }
    }

    function triggerPillarConfetti(pillar) {
      // Get pillar color
      const colorMap = {
        'P1': ['#a8c5ff', '#E8F0FE'],
        'P2': ['#c5b8ff', '#F1ECFF'],
        'P3': ['#90d4a8', '#EAF7EF'],
        'P4': ['#7dd4ca', '#E6F6F4'],
        'P5': ['#ffb366', '#FFF1E6'],
        'P6': ['#ffa8b8', '#FDECEF'],
        'P7': ['#ffd966', '#FFF8E1'],
        'P8': ['#b8bac7', '#F2F3F7']
      };
      
      const colors = colorMap[pillar.id] || ['#007AFF', '#E8F0FE'];
      
      // Subtle confetti burst
      confetti({
        particleCount: 50,
        spread: 60,
        origin: { y: 0.6 },
        colors: colors,
        ticks: 150,
        gravity: 0.8,
        scalar: 0.8
      });
    }

    function checkAndAwardBadges() {
      // Calculate stats for badge checking
      const pillarTouches = {};
      pillars.forEach(p => pillarTouches[p.id] = 0);
      
      let totalToday = 0;
      Object.keys(todayState.completed).forEach(taskId => {
        const pillarId = taskId.split('-')[0];
        if (pillarTouches[pillarId] !== undefined) {
          pillarTouches[pillarId]++;
          totalToday++;
        }
      });

      const totalAllTime = Object.values(statsAllTime).reduce((sum, count) => sum + count, 0);
      const pillarsToday = Object.values(pillarTouches).filter(c => c > 0).length;
      const pillarCompleteToday = Object.values(pillarTouches).some(c => c >= 8);
      const fullPillarsToday = Object.values(pillarTouches).filter(c => c >= 8).length;
      
      // Get balance score (will be 0 if not yet calculated)
      const balanceScoreText = document.getElementById('balanceScore')?.textContent;
      const balanceScore = balanceScoreText && balanceScoreText !== '‚Äî' ? parseInt(balanceScoreText) : 0;

      // Calculate pillar totals all time
      const pillarTotalsAllTime = {};
      pillars.forEach(p => pillarTotalsAllTime[p.id] = 0);
      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split('-');
        if (pillarTotalsAllTime[pillarId] !== undefined) {
          pillarTotalsAllTime[pillarId] += count;
        }
      });
      
      const maxPillarTotal = Math.max(...Object.values(pillarTotalsAllTime));
      const pillarsOver50 = Object.values(pillarTotalsAllTime).filter(c => c >= 50).length;
      
      // Check for special combinations today
      const buildersTrifectaToday = pillarTouches['P2'] > 0 && pillarTouches['P3'] > 0 && pillarTouches['P4'] > 0;
      const creatorsFlowToday = pillarTouches['P1'] > 0 && pillarTouches['P5'] > 0 && pillarTouches['P6'] > 0;
      
      // Check for Mind & Body pattern (P7 + P8 on same day)
      let mindBodyCount = 0;
      Object.keys(dailyHistory).forEach(dateStr => {
        const entry = dailyHistory[dateStr];
        if (entry && entry.pillars) {
          if ((entry.pillars['P7'] || 0) > 0 && (entry.pillars['P8'] || 0) > 0) {
            mindBodyCount++;
          }
        }
      });
      
      // Check for all 8 pillars 3 days in a row
      let allPillarsThreeDays = false;
      const sortedDates = Object.keys(dailyHistory).sort().reverse();
      for (let i = 0; i <= sortedDates.length - 3; i++) {
        const date1 = new Date(sortedDates[i]);
        const date2 = new Date(sortedDates[i + 1]);
        const date3 = new Date(sortedDates[i + 2]);
        
        // Check if consecutive
        const diff1 = Math.floor((date1 - date2) / (1000 * 60 * 60 * 24));
        const diff2 = Math.floor((date2 - date3) / (1000 * 60 * 60 * 24));
        
        if (diff1 === 1 && diff2 === 1) {
          const entry1 = dailyHistory[sortedDates[i]];
          const entry2 = dailyHistory[sortedDates[i + 1]];
          const entry3 = dailyHistory[sortedDates[i + 2]];
          
          if (entry1?.pillars && entry2?.pillars && entry3?.pillars) {
            const pillars1 = Object.values(entry1.pillars).filter(c => c > 0).length;
            const pillars2 = Object.values(entry2.pillars).filter(c => c > 0).length;
            const pillars3 = Object.values(entry3.pillars).filter(c => c > 0).length;
            
            if (pillars1 === 8 && pillars2 === 8 && pillars3 === 8) {
              allPillarsThreeDays = true;
              break;
            }
          }
        }
      }

      const badgeCheckData = {
        totalAllTime,
        totalToday,
        pillarsToday,
        pillarCompleteToday,
        fullPillarsToday,
        currentStreak: streakData.current,
        balanceScore,
        maxPillarTotal,
        pillarsOver50,
        buildersTrifectaToday,
        creatorsFlowToday,
        mindBodyCount,
        allPillarsThreeDays
      };

      let newBadgesEarned = [];

      // Check each badge
      BADGES.forEach(badge => {
        if (!badgesData[badge.id] && badge.check(badgeCheckData)) {
          badgesData[badge.id] = {
            earned: true,
            date: getTodayString()
          };
          newBadgesEarned.push(badge);
        }
      });

      // Save if new badges earned
      if (newBadgesEarned.length > 0) {
        localStorage.setItem(STORAGE_BADGES_KEY, JSON.stringify(badgesData));
        
        // Trigger confetti for badge unlocks
        newBadgesEarned.forEach(badge => {
          confetti({
            particleCount: 40,
            spread: 50,
            origin: { y: 0.7 },
            colors: ['#007AFF', '#FFD700', '#FF6B6B'],
            ticks: 120
          });
        });
        
        // Update badge UI
        renderBadges();
        renderGrowthInsights();
      }
    }

    function renderBadges() {
      const container = document.getElementById('achievementsGrid');
      if (!container) {
        console.error('Achievements container not found!');
        return;
      }
      
      console.log('Rendering badges...', BADGES.length, 'badges defined');
      container.innerHTML = '';

      // Sort badges: unlocked first, then by defined order
      const sortedBadges = [...BADGES].sort((a, b) => {
        const aUnlocked = badgesData[a.id]?.earned || false;
        const bUnlocked = badgesData[b.id]?.earned || false;
        if (aUnlocked && !bUnlocked) return -1;
        if (!aUnlocked && bUnlocked) return 1;
        return 0;
      });

      sortedBadges.forEach(badge => {
        const isUnlocked = badgesData[badge.id]?.earned || false;
        const earnedDate = badgesData[badge.id]?.date;

        const card = document.createElement('div');
        card.className = `badge-card ${isUnlocked ? 'unlocked' : 'locked'}`;
        
        const icon = document.createElement('div');
        icon.className = 'badge-icon';
        icon.textContent = badge.icon;
        
        const name = document.createElement('div');
        name.className = 'badge-name';
        name.textContent = badge.name;
        
        const description = document.createElement('div');
        description.className = 'badge-description';
        description.textContent = badge.description;
        
        card.appendChild(icon);
        card.appendChild(name);
        card.appendChild(description);
        
        if (isUnlocked && earnedDate) {
          const date = document.createElement('div');
          date.className = 'badge-date';
          const d = new Date(earnedDate);
          date.textContent = `Earned ${d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}`;
          card.appendChild(date);
        }
        
        container.appendChild(card);
      });
    }

    function renderGrowthInsights() {
      const container = document.getElementById('growthInsights');
      if (!container) {
        console.error('Growth insights container not found!');
        return;
      }
      
      console.log('Rendering growth insights...');
      container.innerHTML = '';
      
      const totalAllTime = Object.values(statsAllTime).reduce((sum, count) => sum + count, 0);
      
      // Get pillar totals
      const pillarTotalsAllTime = {};
      pillars.forEach(p => pillarTotalsAllTime[p.id] = 0);
      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split('-');
        if (pillarTotalsAllTime[pillarId] !== undefined) {
          pillarTotalsAllTime[pillarId] += count;
        }
      });
      
      // Find strongest pillar
      const maxCount = Math.max(...Object.values(pillarTotalsAllTime));
      const strongestPillar = pillars.find(p => pillarTotalsAllTime[p.id] === maxCount);
      
      // Find most improved (if we have history data)
      const sortedPillars = [...pillars].sort((a, b) => pillarTotalsAllTime[b.id] - pillarTotalsAllTime[a.id]);
      
      // Milestone messages
      const insights = [];
      
      if (totalAllTime === 0) {
        insights.push({
          text: "Your journey begins here. Every master was once a beginner."
        });
      } else if (totalAllTime === 1) {
        insights.push({
          text: "First task complete! <strong>You've started building.</strong>"
        });
      } else if (totalAllTime >= 500) {
        insights.push({
          text: `<strong>${totalAllTime} total completions</strong>‚Äîyou're building a legacy of consistent action.`
        });
      } else if (totalAllTime >= 100) {
        insights.push({
          text: `<strong>${totalAllTime} completions</strong> and counting. Your consistency is your superpower.`
        });
      } else if (totalAllTime >= 50) {
        insights.push({
          text: `You've completed <strong>${totalAllTime} tasks</strong>. Momentum is building.`
        });
      } else if (totalAllTime >= 10) {
        insights.push({
          text: `<strong>${totalAllTime} tasks done.</strong> Small actions are adding up.`
        });
      }
      
      if (strongestPillar && maxCount > 0) {
        const percentage = ((maxCount / totalAllTime) * 100).toFixed(0);
        insights.push({
          text: `<strong>${strongestPillar.name}</strong> is your anchor pillar <em>(${maxCount} completions, ${percentage}% of your total)</em>.`
        });
      }
      
      if (streakData.current >= 7) {
        insights.push({
          text: `<strong>${streakData.current}-day streak active.</strong> You're showing up consistently.`
        });
      } else if (streakData.current >= 3) {
        insights.push({
          text: `<strong>${streakData.current} days in a row.</strong> Keep the momentum going.`
        });
      }
      
      // Show top 3 pillars
      if (totalAllTime >= 20) {
        const top3 = sortedPillars.slice(0, 3).filter(p => pillarTotalsAllTime[p.id] > 0);
        if (top3.length === 3) {
          const names = top3.map(p => p.name).join(', ');
          insights.push({
            text: `Your focus areas: <strong>${names}</strong>.`
          });
        }
      }
      
      // If no insights yet, show encouragement
      if (insights.length === 0) {
        insights.push({
          text: "Complete a few more tasks to unlock personalized growth insights."
        });
      }
      
      // Render insights
      insights.forEach(insight => {
        const item = document.createElement('div');
        item.className = 'growth-insight-item';
        item.innerHTML = insight.text;
        container.appendChild(item);
      });
    }

    function updateTodayReflection() {
      // Count tasks completed today per pillar
      const pillarTouches = {};
      pillars.forEach(p => pillarTouches[p.id] = 0);
      
      let totalToday = 0;
      Object.keys(todayState.completed).forEach(taskId => {
        const pillarId = taskId.split('-')[0];
        if (pillarTouches[pillarId] !== undefined) {
          pillarTouches[pillarId]++;
          totalToday++;
        }
      });

      // Update count
      const pillarsCount = Object.values(pillarTouches).filter(c => c > 0).length;
      document.getElementById('reflectionCount').textContent = 
        totalToday === 0 ? 'No tasks yet' : 
        totalToday === 1 ? '1 task' : 
        `${totalToday} tasks`;

      // Update dots
      document.querySelectorAll('.pillar-dot').forEach(dot => {
        const pillarId = dot.dataset.pillar;
        if (pillarTouches[pillarId] > 0) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });

      // Update insight with coaching voice
      const insightEl = document.getElementById('reflectionInsight');
      const totalAllTime = Object.values(statsAllTime).reduce((sum, count) => sum + count, 0);
      
      if (totalToday === 0) {
        const messages = [
          "Your grid awaits‚Äîeach task is a step forward.",
          "Ready when you are. Small actions add up.",
          "Today is a fresh start. Pick any task to begin."
        ];
        insightEl.textContent = messages[Math.floor(Math.random() * messages.length)];
      } else if (pillarsCount === 8) {
        const messages = [
          "You touched all 8 pillars‚Äîbeautifully balanced.",
          "Perfect harmony across all areas today.",
          "Full spectrum day‚Äîthis is what balance looks like."
        ];
        insightEl.textContent = messages[Math.floor(Math.random() * messages.length)];
      } else if (totalToday === 1) {
        insightEl.textContent = "You've started. Momentum begins with one.";
      } else if (totalToday >= 16) {
        insightEl.textContent = `${totalToday} tasks‚Äîyou're building something real today.`;
      } else if (totalAllTime % 50 === 0 && totalAllTime > 0) {
        insightEl.textContent = `${totalAllTime} total completions‚Äîmilestone reached!`;
      } else if (pillarsCount === 1) {
        const activePillar = pillars.find(p => pillarTouches[p.id] > 0);
        const count = pillarTouches[activePillar.id];
        if (count >= 4) {
          insightEl.textContent = `Deep focus in ${activePillar.name} today‚Äî${count} steps forward.`;
        } else {
          insightEl.textContent = `Focused on ${activePillar.name} today.`;
        }
      } else if (pillarsCount >= 5) {
        insightEl.textContent = `Broad engagement across ${pillarsCount} pillars‚Äîstaying versatile.`;
      } else {
        insightEl.textContent = `Your attention centered on ${pillarsCount} pillars today.`;
      }
    }

    function updateStatsUI() {
      // Hidden table - keeping for potential future use
      const statsBody = document.getElementById("statsBody");
      const statsSummary = document.getElementById("statsSummary");
      if (!statsBody) return;
      
      statsBody.innerHTML = "";

      const pillarTotalsToday = {};
      const pillarTotalsAllTime = {};
      let totalToday = 0;
      let totalAllTime = 0;

      pillars.forEach((p) => {
        pillarTotalsToday[p.id] = 0;
        pillarTotalsAllTime[p.id] = 0;
      });

      Object.keys(todayState.completed).forEach((cellId) => {
        const [pillarId] = cellId.split("-");
        if (pillarTotalsToday[pillarId] !== undefined) {
          pillarTotalsToday[pillarId] += 1;
          totalToday += 1;
        }
      });

      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split("-");
        if (pillarTotalsAllTime[pillarId] !== undefined) {
          pillarTotalsAllTime[pillarId] += count;
          totalAllTime += count;
        }
      });

      pillars.forEach((p) => {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        const tdToday = document.createElement("td");
        const tdAll = document.createElement("td");

        // Name cell (plain text)
        tdName.textContent = p.name;

        // Today progress cell (out of 8)
        const todayCount = pillarTotalsToday[p.id];
        const todayPercent = Math.min((todayCount / 8) * 100, 100);
        tdToday.className = "progress-cell";
        tdToday.innerHTML = `
          <div class="progress-cell-container">
            <div class="progress-fill" style="width: ${todayPercent}%; background-color: ${pillarColors[p.id]};"></div>
            <div class="progress-value">${todayCount}</div>
          </div>
        `;

        // All time progress cell (out of 365)
        const allTimeCount = pillarTotalsAllTime[p.id];
        const allTimePercent = Math.min((allTimeCount / 365) * 100, 100);
        tdAll.className = "progress-cell";
        tdAll.innerHTML = `
          <div class="progress-cell-container">
            <div class="progress-fill" style="width: ${allTimePercent}%; background-color: ${pillarColors[p.id]};"></div>
            <div class="progress-value">${allTimeCount}</div>
          </div>
        `;

        tr.appendChild(tdName);
        tr.appendChild(tdToday);
        tr.appendChild(tdAll);
        
        // Debug: Verify three cells
        const cellCount = tr.children.length;
        if (cellCount !== 3) {
          console.warn(`‚ö†Ô∏è Row for ${p.name} has ${cellCount} cells instead of 3!`);
        }
        
        statsBody.appendChild(tr);
      });

      statsSummary.innerHTML = `
        <span class="today">Today:</span> ${totalToday} tasks completed across all pillars.<br>
        <span class="today">All time:</span> ${totalAllTime} total task completions tracked.
      `;

      updatePillarBalance();
    }

    function calculateFocusStability(datesInRange) {
      // Filter to days with non-zero completions
      const nonZeroDays = datesInRange.filter(dateStr => {
        const entry = dailyHistory[dateStr];
        const total = entry ? (entry.total || entry) : 0;
        return total > 0;
      });
      
      if (nonZeroDays.length < 3) {
        return {
          score: null,
          classification: null,
          description: "Complete tasks across at least 3 different days to unlock stability insights."
        };
      }

      // Calculate daily pillar shares using actual data
      const dailyShares = [];
      
      nonZeroDays.forEach(dateStr => {
        const entry = dailyHistory[dateStr];
        if (!entry || !entry.pillars) return; // Skip if no pillar data
        
        const dayTotal = entry.total || 0;
        if (dayTotal === 0) return;
        
        const shares = {};
        pillars.forEach(p => {
          shares[p.id] = (entry.pillars[p.id] || 0) / dayTotal;
        });
        
        dailyShares.push(shares);
      });
      
      if (dailyShares.length < 3) {
        return {
          score: null,
          classification: '‚Äî',
          description: 'Need at least 3 days with pillar data to calculate stability.'
        };
      }
      
      // Calculate variance for each pillar across days
      const pillarVariances = [];
      
      pillars.forEach(pillar => {
        const pillarShares = dailyShares.map(day => day[pillar.id]);
        const mean = pillarShares.reduce((sum, val) => sum + val, 0) / pillarShares.length;
        const variance = pillarShares.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / pillarShares.length;
        pillarVariances.push(variance);
      });
      
      // Average variance across all pillars (volatility index)
      const avgVariance = pillarVariances.reduce((sum, v) => sum + v, 0) / pillarVariances.length;
      
      // Convert to 0-10 scale (lower variance = higher stability)
      // Variance ranges roughly 0-0.1 for typical patterns
      const stabilityScore = Math.max(0, Math.min(10, Math.round(10 - (avgVariance * 100))));
      
      let classification, description;
      
      if (stabilityScore >= 8) {
        classification = 'Steady';
        description = 'Your focus pattern has been consistent.';
      } else if (stabilityScore >= 5) {
        classification = 'Moderate';
        description = 'Your focus shifts moderately between pillars.';
      } else {
        classification = 'Dynamic';
        description = 'Your focus varies significantly day to day.';
      }
      
      return {
        score: stabilityScore,
        classification,
        description
      };
    }

    function oldCalculateFocusStability_REMOVED(datesInRange) {
      // Old approximation-based code removed
      const allTimePillarTotals = {};
      pillars.forEach(p => allTimePillarTotals[p.id] = 0);
      Object.entries(statsAllTime).forEach(([cellId, count]) => {
        const [pillarId] = cellId.split('-');
        if (allTimePillarTotals[pillarId] !== undefined) {
          allTimePillarTotals[pillarId] += count;
        }
      });
      const allTimeTotal = Object.values(allTimePillarTotals).reduce((sum, v) => sum + v, 0);
      
      // For each day, approximate pillar shares using all-time distribution
      const dailyShares = {}; // pillarId -> array of daily shares
      pillars.forEach(p => dailyShares[p.id] = []);
      
      nonZeroDays.forEach(dateStr => {
        const dayTotal = dailyHistory[dateStr];
        if (dayTotal > 0) {
          pillars.forEach(p => {
            // Approximate pillar count for this day using all-time ratio
            const pillarRatio = allTimeTotal > 0 ? allTimePillarTotals[p.id] / allTimeTotal : 1/8;
            const estimatedPillarCount = dayTotal * pillarRatio;
            const share = estimatedPillarCount / dayTotal;
            dailyShares[p.id].push(share);
          });
        }
      });
      
      // Calculate standard deviation for each pillar's daily shares
      const pillarStdDevs = [];
      pillars.forEach(p => {
        const shares = dailyShares[p.id];
        if (shares.length > 0) {
          const mean = shares.reduce((sum, s) => sum + s, 0) / shares.length;
          const variance = shares.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / shares.length;
          const stdDev = Math.sqrt(variance);
          pillarStdDevs.push(stdDev);
        }
      });
      
      // Average the standard deviations to get volatility index
      const volatilityIndex = pillarStdDevs.reduce((sum, sd) => sum + sd, 0) / pillarStdDevs.length;
      
      // Normalize and convert to 0-10 stability score (inverse of volatility)
      // Cap volatilityIndex at 0.25 for normalization
      const cappedVolatility = Math.min(volatilityIndex, 0.25);
      const normalizedVolatility = cappedVolatility / 0.25;
      const stabilityScore = Math.round((1 - normalizedVolatility) * 10);
      const clampedScore = Math.max(0, Math.min(10, stabilityScore));
      
      // Classify
      let classification, description;
      if (clampedScore >= 8) {
        classification = "Steady";
        description = "Your focus pattern has been consistent.";
      } else if (clampedScore >= 5) {
        classification = "Moderate";
        description = "Your attention shifts moderately between pillars.";
      } else {
        classification = "Dynamic";
        description = "Your focus moves frequently across different areas.";
      }
      
      return {
        score: clampedScore,
        classification: classification,
        description: description
      };
    }

    function renderActivityTimeline(datesInRange) {
      const chartContainer = document.getElementById('timelineChart');
      const labelsContainer = document.getElementById('timelineLabels');
      
      if (!chartContainer || !labelsContainer) return;
      
      chartContainer.innerHTML = '';
      labelsContainer.innerHTML = '';
      
      const today = getTodayString();
      const maxBars = 90; // Limit to 90 bars for visual clarity
      const datesToShow = datesInRange.slice(-maxBars);
      
      // Calculate max value for scaling
      const values = datesToShow.map(date => {
        const entry = dailyHistory[date];
        return entry ? (entry.total || entry) : 0;
      });
      const maxValue = Math.max(...values, 8);
      
      // Create bars
      datesToShow.forEach((dateStr, index) => {
        const entry = dailyHistory[dateStr];
        const count = entry ? (entry.total || entry) : 0;
        const isToday = dateStr === today;
        const date = new Date(dateStr);
        
        const bar = document.createElement('div');
        bar.className = 'timeline-bar';
        if (count > 0) bar.classList.add('has-data');
        if (isToday) bar.classList.add('is-today');
        
        const heightPercent = count > 0 ? (count / maxValue) * 100 : 8;
        bar.style.height = `${heightPercent}%`;
        
        const tooltip = document.createElement('div');
        tooltip.className = 'timeline-bar-tooltip';
        const formattedDate = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        tooltip.textContent = `${formattedDate}: ${count} tasks`;
        bar.appendChild(tooltip);
        
        chartContainer.appendChild(bar);
      });
      
      // Add labels (first, middle, last)
      if (datesToShow.length > 0) {
        const firstDate = new Date(datesToShow[0]);
        const lastDate = new Date(datesToShow[datesToShow.length - 1]);
        
        const firstLabel = document.createElement('span');
        firstLabel.textContent = firstDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        
        const lastLabel = document.createElement('span');
        lastLabel.textContent = lastDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        
        labelsContainer.appendChild(firstLabel);
        labelsContainer.appendChild(lastLabel);
      }
    }

    function updatePillarBalance() {
      // Get range window and filter completions
      const rangeWindow = getRangeWindow(selectedTimeRange);
      const completionEvents = getCompletionsInRange(rangeWindow);
      
      // Debug logging
      console.log('=== Balance Over Time Debug ===');
      console.log('selectedRangeKey:', selectedTimeRange);
      console.log('rangeWindow:', rangeWindow);
      console.log('eventsInRange:', completionEvents.length);
      
      // Calculate pillar totals from completion events
      const countsByPillar = {};
      pillars.forEach(p => countsByPillar[p.id] = 0);
      
      completionEvents.forEach(event => {
        if (countsByPillar[event.pillarId] !== undefined) {
          countsByPillar[event.pillarId]++;
        }
      });
      
      console.log('countsByPillar:', countsByPillar);
      
      // Get date strings for timeline rendering
      const datesInRange = [];
      const currentDate = new Date(rangeWindow.startDate);
      while (currentDate <= rangeWindow.endDate) {
        datesInRange.push(currentDate.toISOString().split('T')[0]);
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      // Render activity timeline
      renderActivityTimeline(datesInRange);
      
      const totalCompletions = completionEvents.length;
      const values = pillars.map(p => countsByPillar[p.id] || 0);
      
      // Handle empty state - no completions in this range
      if (totalCompletions === 0) {
        const balanceScore = document.getElementById('balanceScore');
        if (balanceScore) balanceScore.textContent = '‚Äî';
        const balanceDescription = document.getElementById('balanceDescription');
        if (balanceDescription) balanceDescription.textContent = 'No completions in this range yet.';
        const focusPatternPrimary = document.getElementById('focusPatternPrimary');
        if (focusPatternPrimary) focusPatternPrimary.textContent = '‚Äî';
        const focusPatternDescription = document.getElementById('focusPatternDescription');
        if (focusPatternDescription) focusPatternDescription.textContent = 'No data in selected range.';
        const focusPatternSecondary = document.getElementById('focusPatternSecondary');
        if (focusPatternSecondary) focusPatternSecondary.textContent = '';
        const stabilityScore = document.getElementById('stabilityScore');
        if (stabilityScore) stabilityScore.textContent = '‚Äî';
        const stabilityDescription = document.getElementById('stabilityDescription');
        if (stabilityDescription) stabilityDescription.textContent = 'No data in selected range.';
        const balanceTrend = document.getElementById('balanceTrend');
        if (balanceTrend) balanceTrend.textContent = '‚Äî';
        const balanceTrendDescription = document.getElementById('balanceTrendDescription');
        if (balanceTrendDescription) balanceTrendDescription.textContent = 'No data to compare.';
        const balanceFooter = document.getElementById('balanceFooter');
        if (balanceFooter) balanceFooter.textContent = 'Complete tasks to see balance insights here.';
        
        // Render empty radar chart
        renderRadarChart(values);
        return;
      }

      // Calculate coefficient of variation (lower = more balanced)
      const mean = totalCompletions / values.length;
      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      const stdDev = Math.sqrt(variance);
      const cv = mean > 0 ? (stdDev / mean) : 0;
      
      // Convert to 0-100 scale (invert so 100 = perfectly balanced)
      const balanceScore = Math.round(Math.max(0, 100 - (cv * 100)));
      
      const balanceScoreEl = document.getElementById('balanceScore');
      if (balanceScoreEl) balanceScoreEl.textContent = balanceScore;
      
      let description = '';
      if (balanceScore >= 80) description = 'Well-distributed across all pillars.';
      else if (balanceScore >= 60) description = 'Mostly balanced with a few areas standing out.';
      else if (balanceScore >= 40) description = 'Some concentration in select areas.';
      else description = 'Focus is heavily concentrated.';
      
      const balanceDescriptionEl = document.getElementById('balanceDescription');
      if (balanceDescriptionEl) balanceDescriptionEl.textContent = description;

      // Find most neglected and most active pillars
      const minValue = Math.min(...values);
      const minIndex = values.indexOf(minValue);
      const neglectedPillar = pillars[minIndex];
      
      const maxValue = Math.max(...values);
      const maxIndex = values.indexOf(maxValue);
      const activePillar = pillars[maxIndex];
      const percentage = totalCompletions > 0 ? Math.round((maxValue / totalCompletions) * 100) : 0;
      
      // Update Focus Pattern card (merged Most Active + Most Neglected)
      const focusPatternPrimary = document.getElementById('focusPatternPrimary');
      if (focusPatternPrimary) focusPatternPrimary.textContent = activePillar.name;
      const focusPatternDescription = document.getElementById('focusPatternDescription');
      if (focusPatternDescription) focusPatternDescription.textContent = 
        `Your current anchor (${percentage}% of activity).`;
      const focusPatternSecondary = document.getElementById('focusPatternSecondary');
      if (focusPatternSecondary) focusPatternSecondary.textContent = 
        neglectedPillar.id !== activePillar.id ? 
        `${neglectedPillar.name} could use attention.` : 
        'Focus is evenly distributed.';

      // Calculate and display balance trend
      const rangeLength = datesInRange.length;
      
      // Calculate previous period window
      let previousRangeWindow;
      if (selectedTimeRange === "ytd" || selectedTimeRange === "all") {
        // For YTD and All Time, compare to same period length ending before current range
        const previousEndDate = new Date(rangeWindow.startDate);
        previousEndDate.setDate(previousEndDate.getDate() - 1);
        const previousStartDate = new Date(previousEndDate);
        previousStartDate.setDate(previousStartDate.getDate() - (rangeLength - 1));
        previousRangeWindow = { startDate: previousStartDate, endDate: previousEndDate };
      } else {
        // For Last N days, compare to previous N days
        const days = parseInt(selectedTimeRange);
        const previousEndDate = new Date(rangeWindow.startDate);
        previousEndDate.setDate(previousEndDate.getDate() - 1);
        const previousStartDate = new Date(previousEndDate);
        previousStartDate.setDate(previousStartDate.getDate() - (days - 1));
        previousRangeWindow = { startDate: previousStartDate, endDate: previousEndDate };
      }
      
      const previousCompletions = getCompletionsInRange(previousRangeWindow);
      const previousTotal = previousCompletions.length;
      
      if (previousTotal === 0 || rangeLength < 3) {
        const balanceTrend = document.getElementById('balanceTrend');
        if (balanceTrend) balanceTrend.textContent = '‚Äî';
        const balanceTrendDescription = document.getElementById('balanceTrendDescription');
        if (balanceTrendDescription) balanceTrendDescription.textContent = 'Not enough prior data to compare.';
      } else {
        // Calculate previous pillar distribution
        const previousCountsByPillar = {};
        pillars.forEach(p => previousCountsByPillar[p.id] = 0);
        previousCompletions.forEach(event => {
          if (previousCountsByPillar[event.pillarId] !== undefined) {
            previousCountsByPillar[event.pillarId]++;
          }
        });
        
        const previousValues = pillars.map(p => previousCountsByPillar[p.id] || 0);
        const previousMean = previousTotal / previousValues.length;
        const previousVariance = previousValues.reduce((sum, v) => sum + Math.pow(v - previousMean, 2), 0) / previousValues.length;
        const previousStdDev = Math.sqrt(previousVariance);
        const previousCv = previousMean > 0 ? (previousStdDev / previousMean) : 0;
        const previousBalanceScore = Math.round(Math.max(0, 100 - (previousCv * 100)));
        
        const delta = balanceScore - previousBalanceScore;
        const absDelta = Math.abs(delta);
        
        if (delta > 0) {
          const balanceTrend = document.getElementById('balanceTrend');
          if (balanceTrend) balanceTrend.textContent = `+${delta}`;
          const balanceTrendDescription = document.getElementById('balanceTrendDescription');
          if (balanceTrendDescription) balanceTrendDescription.textContent = 
            `More balanced than previous period (+${absDelta}).`;
        } else if (delta < 0) {
          const balanceTrend = document.getElementById('balanceTrend');
          if (balanceTrend) balanceTrend.textContent = `${delta}`;
          const balanceTrendDescription = document.getElementById('balanceTrendDescription');
          if (balanceTrendDescription) balanceTrendDescription.textContent = 
            `Less balanced than previous period (-${absDelta}).`;
        } else {
          const balanceTrend = document.getElementById('balanceTrend');
          if (balanceTrend) balanceTrend.textContent = '0';
          const balanceTrendDescription = document.getElementById('balanceTrendDescription');
          if (balanceTrendDescription) balanceTrendDescription.textContent = 
            'Same balance as previous period.';
        }
      }

      // Calculate and display focus stability
      const stability = calculateFocusStability(datesInRange);
      
      if (stability.score === null) {
        const stabilityScore = document.getElementById('stabilityScore');
        if (stabilityScore) stabilityScore.textContent = '‚Äî';
        const stabilityDescription = document.getElementById('stabilityDescription');
        if (stabilityDescription) stabilityDescription.textContent = stability.description;
      } else {
        const stabilityScore = document.getElementById('stabilityScore');
        if (stabilityScore) stabilityScore.textContent = `${stability.classification} (${stability.score}/10)`;
        const stabilityDescription = document.getElementById('stabilityDescription');
        if (stabilityDescription) stabilityDescription.textContent = stability.description;
      }

      // Update balance footer with contextual message
      const balanceFooter = document.getElementById('balanceFooter');
      if (balanceFooter) {
        const nonZeroDays = datesInRange.filter(dateStr => {
          const entry = dailyHistory[dateStr];
          return (entry ? (entry.total || entry) : 0) > 0;
        });
        
        if (nonZeroDays.length < 3) {
          balanceFooter.textContent = "Build a few more days of data to reveal deeper patterns.";
        } else if (balanceScore >= 75) {
          balanceFooter.textContent = "Your attention flows naturally across all areas.";
        } else if (balanceScore >= 50) {
          balanceFooter.textContent = "There's room to explore pillars beyond your anchors.";
        } else {
          balanceFooter.textContent = "Your energy is concentrated‚Äîintentional or opportunity?";
        }
      }

      // Render radar chart
      renderRadarChart(values);
    }

    function renderRadarChart(values) {
      const canvas = document.getElementById('radarChart');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 120;
      
      // Store data point positions for hover detection
      const dataPoints = [];
      
      // Use dynamic scaling: scale based on max value, but ensure data spreads out
      const maxValue = Math.max(...values);
      const minValue = Math.min(...values);
      const range = maxValue - minValue;
      
      // If range is very small or zero, use expanded scale for better visibility
      let scale = maxValue;
      if (range < maxValue * 0.3 || maxValue === 0) {
        // Use 150% of max to leave room at edges
        scale = Math.max(maxValue * 1.5, 8);
      }
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid circles
      ctx.strokeStyle = '#e5e5ea';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#d2d2d7';
      ctx.lineWidth = 1;
      pillars.forEach((pillar, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.stroke();
      });
      
      // Draw labels
      ctx.fillStyle = '#1d1d1f';
      ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      pillars.forEach((pillar, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const labelRadius = radius + 24;
        const x = centerX + Math.cos(angle) * labelRadius;
        const y = centerY + Math.sin(angle) * labelRadius;
        
        ctx.fillText(`P${i + 1}`, x, y);
      });
      
      // Draw data polygon
      ctx.fillStyle = 'rgba(0, 122, 255, 0.15)';
      ctx.strokeStyle = '#007AFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      values.forEach((value, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const valueRadius = (value / scale) * radius;
        const x = centerX + Math.cos(angle) * valueRadius;
        const y = centerY + Math.sin(angle) * valueRadius;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Draw data points and store positions
      ctx.fillStyle = '#007AFF';
      values.forEach((value, i) => {
        const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
        const valueRadius = (value / scale) * radius;
        const x = centerX + Math.cos(angle) * valueRadius;
        const y = centerY + Math.sin(angle) * valueRadius;
        
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Store point data for hover detection
        dataPoints.push({
          x: x,
          y: y,
          pillar: pillars[i],
          value: value
        });
      });
      
      // Add hover interaction
      setupRadarHover(canvas, dataPoints);
    }
    
    function setupRadarHover(canvas, dataPoints) {
      const tooltip = document.getElementById('radarTooltip');
      const rect = canvas.getBoundingClientRect();
      
      canvas.onmousemove = (e) => {
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        let hoveredPoint = null;
        const hoverRadius = 12; // Larger hit area for easier hovering
        
        for (const point of dataPoints) {
          const distance = Math.sqrt(
            Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2)
          );
          
          if (distance <= hoverRadius) {
            hoveredPoint = point;
            break;
          }
        }
        
        if (hoveredPoint) {
          const pillarName = hoveredPoint.pillar.name;
          const taskCount = hoveredPoint.value;
          const plural = taskCount === 1 ? 'task' : 'tasks';
          
          tooltip.querySelector('.radar-tooltip-pillar').textContent = pillarName;
          tooltip.querySelector('.radar-tooltip-value').textContent = `${taskCount} ${plural} completed`;
          
          tooltip.style.left = `${e.clientX - rect.left + 15}px`;
          tooltip.style.top = `${e.clientY - rect.top - 10}px`;
          tooltip.classList.add('visible');
        } else {
          tooltip.classList.remove('visible');
        }
      };
      
      canvas.onmouseleave = () => {
        tooltip.classList.remove('visible');
      };
    }

    // Time range configuration
    const TIME_RANGES = {
      '7': { key: '7d', label: 'Last 7 days', days: 7 },
      '30': { key: '30d', label: 'Last 30 days', days: 30 },
      '90': { key: '90d', label: 'Last 90 days', days: 90 },
      'ytd': { key: 'ytd', label: 'YTD', days: null },
      'all': { key: 'all', label: 'All Time', days: null }
    };

    // Get date range window for a given range key
    function getRangeWindow(rangeKey, nowDate = new Date()) {
      const today = new Date(nowDate);
      today.setHours(0, 0, 0, 0);
      
      if (rangeKey === 'ytd') {
        // Year to Date: Jan 1 of current year -> today
        const startDate = new Date(today.getFullYear(), 0, 1);
        return { startDate, endDate: today };
      } else if (rangeKey === 'all') {
        // All Time: earliest event date -> today
        const allDates = Object.keys(dailyHistory);
        if (allDates.length === 0) {
          return { startDate: today, endDate: today };
        }
        const earliestDate = new Date(Math.min(...allDates.map(d => new Date(d))));
        return { startDate: earliestDate, endDate: today };
      } else {
        // Last N days inclusive
        const days = parseInt(rangeKey);
        const startDate = new Date(today);
        startDate.setDate(startDate.getDate() - (days - 1));
        return { startDate, endDate: today };
      }
    }

    // Get all completions in a date range
    function getCompletionsInRange(rangeWindow) {
      const completions = [];
      const { startDate, endDate } = rangeWindow;
      
      // Iterate through all dates in the range
      const currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        const dateStr = currentDate.toISOString().split('T')[0];
        const entry = dailyHistory[dateStr];
        
        if (entry) {
          const total = entry.total || entry;
          const pillars = entry.pillars || {};
          
          // Create individual completion events
          for (const pillarId in pillars) {
            const count = pillars[pillarId];
            for (let i = 0; i < count; i++) {
              completions.push({
                date: dateStr,
                pillarId: pillarId,
                timestamp: new Date(dateStr).getTime()
              });
            }
          }
        }
        
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      return completions;
    }

    function updateTimeRangeButtons() {
      const today = new Date();
      
      document.querySelectorAll('.time-range-btn').forEach(btn => {
        const rangeDataAttr = btn.dataset.range;
        const rangeConfig = TIME_RANGES[rangeDataAttr];
        
        if (!rangeConfig) return;
        
        // Get range window
        const rangeWindow = getRangeWindow(rangeDataAttr, today);
        const completions = getCompletionsInRange(rangeWindow);
        const totalTasks = completions.length;
        
        // Set button text properly using string label
        btn.textContent = `${rangeConfig.label} (${totalTasks})`;
      });
    }

    // ===============================================
    // NEW ANALYTICS FUNCTIONS
    // ===============================================

    // Calculate pillar streaks
    function calculatePillarStreaks() {
      const today = getTodayString();
      
      pillars.forEach(pillar => {
        const pillarId = pillar.id;
        
        // Check if pillar was active today
        const todayActive = Object.keys(todayState.completed).some(cellId => cellId.startsWith(pillarId + '-'));
        
        if (todayActive) {
          pillarStreaks[pillarId].current++;
          pillarStreaks[pillarId].best = Math.max(pillarStreaks[pillarId].best, pillarStreaks[pillarId].current);
          pillarStreaks[pillarId].lastActive = today;
        } else {
          // Check if streak should reset
          const lastActive = pillarStreaks[pillarId].lastActive;
          if (lastActive) {
            const lastDate = new Date(lastActive);
            const todayDate = new Date(today);
            const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
            
            if (daysDiff > 1) {
              pillarStreaks[pillarId].current = 0;
            }
          }
        }
      });
      
      localStorage.setItem(STORAGE_PILLAR_STREAKS_KEY, JSON.stringify(pillarStreaks));
    }

    // Get days since last activity for a pillar
    function getDaysSinceLastActivity(pillarId) {
      const lastActive = pillarStreaks[pillarId].lastActive;
      if (!lastActive) return 999;
      
      const today = new Date(getTodayString());
      const lastDate = new Date(lastActive);
      return Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
    }

    // Render Priority Alignment
    function renderPriorityAlignment() {
      const container = document.getElementById('priorityGrid');
      if (!container) return;

      // Calculate actual percentages
      const pillarTotals = {};
      let totalTasks = 0;
      
      pillars.forEach(p => pillarTotals[p.id] = 0);
      
      Object.keys(todayState.completed).forEach(cellId => {
        const pillarId = cellId.split('-')[0];
        if (pillarTotals[pillarId] !== undefined) {
          pillarTotals[pillarId]++;
          totalTasks++;
        }
      });

      // Get targets from settings
      const targets = userSettings.pillarTargets;
      
      container.innerHTML = '';
      
      pillars.forEach(pillar => {
        const actual = totalTasks > 0 ? Math.round((pillarTotals[pillar.id] / totalTasks) * 100) : 0;
        const target = targets[pillar.id] || 12.5;
        const diff = actual - target;
        const absDiff = Math.abs(diff);
        
        let statusClass, statusText, statusEmoji;
        if (absDiff <= 5) {
          statusClass = 'status-on-track';
          statusText = 'ON TRACK';
          statusEmoji = 'üü¢';
        } else if (diff < 0) {
          statusClass = 'status-under';
          statusText = absDiff > 15 ? 'WAY UNDER' : 'UNDER';
          statusEmoji = 'üî¥';
        } else {
          statusClass = 'status-over';
          statusText = absDiff > 15 ? 'OVER-INDEXED' : 'OVER';
          statusEmoji = 'üü°';
        }
        
        const row = document.createElement('div');
        row.className = 'priority-row';
        row.innerHTML = `
          <div class="priority-pillar-name">${pillar.name}</div>
          <div class="priority-bars">
            <span class="priority-label">Target:</span>
            <div class="priority-bar-container">
              <div class="priority-bar" style="width: ${target}%; background: #d1d1d6;">${target}%</div>
            </div>
          </div>
          <div class="priority-bars">
            <span class="priority-label">Actual:</span>
            <div class="priority-bar-container">
              <div class="priority-bar" style="width: ${actual}%; background: ${actual > target + 5 ? '#ff9500' : actual < target - 5 ? '#ff3b30' : '#34c759'};">${actual}%</div>
            </div>
          </div>
          <div class="priority-status ${statusClass}">${statusEmoji} ${statusText}</div>
        `;
        container.appendChild(row);
      });
    }

    // Render Streaks & Momentum
    function renderStreaks() {
      const container = document.getElementById('streaksGrid');
      const atRiskContainer = document.getElementById('atRiskContainer');
      const summaryContainer = document.getElementById('momentumSummary');
      
      if (!container) return;

      calculatePillarStreaks();
      
      container.innerHTML = '';
      const atRiskPillars = [];
      
      pillars.forEach(pillar => {
        const streak = pillarStreaks[pillar.id];
        const daysSince = getDaysSinceLastActivity(pillar.id);
        
        if (daysSince >= 3) {
          atRiskPillars.push({ pillar, daysSince, previousStreak: streak.best });
        }
        
        if (streak.current > 0 || streak.best > 0) {
          const card = document.createElement('div');
          card.className = 'streak-card';
          
          const isNewRecord = streak.current > 0 && streak.current === streak.best;
          
          card.innerHTML = `
            <div class="streak-card-header">
              <span class="streak-icon">üî•</span>
              <span class="streak-pillar-name">${pillar.name}</span>
            </div>
            <div class="streak-value">${streak.current}-day streak</div>
            <div class="streak-best ${isNewRecord ? 'streak-new-record' : ''}">
              Longest: ${streak.best} days ${isNewRecord ? '- NEW RECORD!' : ''}
            </div>
          `;
          container.appendChild(card);
        }
      });

      // Render at-risk section
      if (atRiskContainer) {
        if (atRiskPillars.length > 0) {
          let html = '<div class="at-risk-section">';
          html += '<div class="at-risk-title">‚ö†Ô∏è AT RISK:</div>';
          atRiskPillars.forEach(({ pillar, daysSince, previousStreak }) => {
            html += `<div class="at-risk-item">${pillar.name}: ${daysSince} days since last activity${previousStreak > 0 ? ` (was on a ${previousStreak}-day streak)` : ''}</div>`;
          });
          html += '</div>';
          atRiskContainer.innerHTML = html;
        } else {
          atRiskContainer.innerHTML = '';
        }
      }

      // Momentum summary
      if (summaryContainer) {
        const activeStreaks = Object.values(pillarStreaks).filter(s => s.current > 0).length;
        const totalPillars = pillars.length;
        
        let momentum;
        if (activeStreaks >= 6) momentum = 'üìà OVERALL MOMENTUM: STRONG';
        else if (activeStreaks >= 4) momentum = 'üìà OVERALL MOMENTUM: GOOD';
        else if (activeStreaks >= 2) momentum = 'üìà OVERALL MOMENTUM: BUILDING';
        else momentum = 'üìà OVERALL MOMENTUM: NEEDS WORK';
        
        summaryContainer.innerHTML = `
          <strong>${momentum}</strong><br>
          You're maintaining consistency across ${activeStreaks} of ${totalPillars} pillars. ${atRiskPillars.length > 0 ? "Don't let " + atRiskPillars[0].pillar.name + " slip!" : "Keep it up!"}
        `;
      }
    }

    // Render Daily Recommendations
    function renderRecommendations() {
      const container = document.getElementById('recommendationsList');
      if (!container) return;

      container.innerHTML = '';
      
      // Calculate current balance
      const pillarTotals = {};
      let totalToday = 0;
      pillars.forEach(p => pillarTotals[p.id] = 0);
      Object.keys(todayState.completed).forEach(cellId => {
        const pillarId = cellId.split('-')[0];
        if (pillarTotals[pillarId] !== undefined) {
          pillarTotals[pillarId]++;
          totalToday++;
        }
      });

      const targets = userSettings.pillarTargets;
      const weights = userSettings.goalWeights;
      
      // Find neglected high-priority pillars
      const recommendations = [];
      
      pillars.forEach(pillar => {
        const actual = totalToday > 0 ? (pillarTotals[pillar.id] / totalToday) * 100 : 0;
        const target = targets[pillar.id];
        const weight = weights[pillar.id];
        const daysSince = getDaysSinceLastActivity(pillar.id);
        
        const score = weight * (target - actual) + (daysSince * 2);
        
        recommendations.push({
          pillar,
          score,
          actual,
          target,
          weight,
          daysSince
        });
      });

      // Sort by score (highest first)
      recommendations.sort((a, b) => b.score - a.score);
      
      // High priority (top 2 if significantly under target)
      const highPriority = recommendations.slice(0, 2).filter(r => r.actual < r.target - 5 || r.daysSince >= 3);
      
      if (highPriority.length > 0) {
        highPriority.forEach(rec => {
          const taskCount = Math.ceil((rec.target - rec.actual) / 10) || 1;
          const item = document.createElement('div');
          item.className = 'recommendation-item high-priority';
          item.innerHTML = `
            <div class="recommendation-title">üéØ ${rec.pillar.name} (${taskCount} tasks)</div>
            <div class="recommendation-why">
              Why: ${rec.daysSince >= 3 ? `${rec.daysSince} days since last activity, streak at risk` : `Primary goal + only ${Math.round(rec.actual)}% vs ${rec.target}% target`}
            </div>
          `;
          container.appendChild(item);
        });
      }

      // Dial back (over-indexed)
      const overIndexed = recommendations.filter(r => r.actual > r.target + 15);
      if (overIndexed.length > 0) {
        const rec = overIndexed[0];
        const item = document.createElement('div');
        item.className = 'recommendation-item dial-back';
        item.innerHTML = `
          <div class="recommendation-title">‚ö†Ô∏è DIAL BACK: ${rec.pillar.name}</div>
          <div class="recommendation-why">
            You're over-indexing here (${Math.round(rec.actual)}% vs ${rec.target}% target). Do 1 task max today, save energy for priority areas.
          </div>
        `;
        container.appendChild(item);
      }

      // Maintain (on track with streaks)
      const maintain = recommendations.filter(r => 
        Math.abs(r.actual - r.target) <= 5 && 
        pillarStreaks[r.pillar.id].current >= 7
      );
      
      if (maintain.length > 0) {
        maintain.slice(0, 2).forEach(rec => {
          const item = document.createElement('div');
          item.className = 'recommendation-item maintain';
          item.innerHTML = `
            <div class="recommendation-title">‚úÖ MAINTAIN: ${rec.pillar.name} (1-2 tasks)</div>
            <div class="recommendation-why">
              ${pillarStreaks[rec.pillar.id].current}-day streak, keep momentum!
            </div>
          `;
          container.appendChild(item);
        });
      }

      if (container.children.length === 0) {
        container.innerHTML = '<div style="color: #6e6e73; font-size: 0.8rem;">Complete more tasks to get personalized recommendations.</div>';
      }
    }

    // Render Weekly Summary
    function renderWeeklySummary() {
      const winsContainer = document.getElementById('weeklySummaryWins');
      const gapsContainer = document.getElementById('weeklySummaryGaps');
      const trendsContainer = document.getElementById('weeklySummaryTrends');
      
      if (!winsContainer || !gapsContainer || !trendsContainer) return;

      // Get last 7 days
      const today = new Date();
      const weekAgo = new Date(today);
      weekAgo.setDate(weekAgo.getDate() - 7);
      
      const thisWeekPillarTotals = {};
      let thisWeekTotal = 0;
      pillars.forEach(p => thisWeekPillarTotals[p.id] = 0);
      
      // Count this week's completions
      for (let d = new Date(weekAgo); d <= today; d.setDate(d.getDate() + 1)) {
        const dateStr = d.toISOString().split('T')[0];
        const entry = dailyHistory[dateStr];
        if (entry && entry.pillars) {
          Object.keys(entry.pillars).forEach(pillarId => {
            if (thisWeekPillarTotals[pillarId] !== undefined) {
              thisWeekPillarTotals[pillarId] += entry.pillars[pillarId];
              thisWeekTotal += entry.pillars[pillarId];
            }
          });
        }
      }

      // Previous week
      const twoWeeksAgo = new Date(weekAgo);
      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 7);
      
      const lastWeekPillarTotals = {};
      pillars.forEach(p => lastWeekPillarTotals[p.id] = 0);
      
      for (let d = new Date(twoWeeksAgo); d < weekAgo; d.setDate(d.getDate() + 1)) {
        const dateStr = d.toISOString().split('T')[0];
        const entry = dailyHistory[dateStr];
        if (entry && entry.pillars) {
          Object.keys(entry.pillars).forEach(pillarId => {
            if (lastWeekPillarTotals[pillarId] !== undefined) {
              lastWeekPillarTotals[pillarId] += entry.pillars[pillarId];
            }
          });
        }
      }

      // Render wins
      winsContainer.innerHTML = '';
      const wins = [];
      
      pillars.forEach(pillar => {
        const count = thisWeekPillarTotals[pillar.id];
        const streak = pillarStreaks[pillar.id];
        
        if (streak.current >= 7) {
          wins.push({ text: `${streak.current}-day streak maintained (${pillar.name})`, icon: 'üî•' });
        }
        
        if (count >= 8) {
          const lastWeek = lastWeekPillarTotals[pillar.id];
          const growth = lastWeek > 0 ? Math.round(((count - lastWeek) / lastWeek) * 100) : 0;
          wins.push({ 
            text: `${count} tasks in ${pillar.name}${growth > 0 ? ` - up ${growth}% from last week!` : ''}`, 
            icon: '‚úÖ' 
          });
        }
      });

      if (wins.length > 0) {
        wins.forEach(win => {
          const item = document.createElement('div');
          item.className = 'summary-item';
          item.setAttribute('data-icon', win.icon);
          item.textContent = win.text;
          winsContainer.appendChild(item);
        });
      } else {
        winsContainer.innerHTML = '<div class="summary-item" data-icon="üí≠">Build momentum this week to see wins here!</div>';
      }

      // Render gaps
      gapsContainer.innerHTML = '';
      const gaps = [];
      
      pillars.forEach(pillar => {
        const count = thisWeekPillarTotals[pillar.id];
        const lastWeek = lastWeekPillarTotals[pillar.id];
        
        if (count === 0) {
          gaps.push({ text: `0 activities this week (${pillar.name})`, icon: '‚ùå' });
        } else if (count <= 2 && lastWeek >= 5) {
          const drop = Math.round(((lastWeek - count) / lastWeek) * 100);
          gaps.push({ text: `Only ${count} tasks in ${pillar.name} - down ${drop}% from last week`, icon: '‚ùå' });
        }
      });

      if (gaps.length > 0) {
        gaps.forEach(gap => {
          const item = document.createElement('div');
          item.className = 'summary-item';
          item.setAttribute('data-icon', gap.icon);
          item.textContent = gap.text;
          gapsContainer.appendChild(item);
        });
      } else {
        gapsContainer.innerHTML = '<div class="summary-item" data-icon="‚ú®">No major gaps - great balance!</div>';
      }

      // Render trends
      trendsContainer.innerHTML = '';
      
      pillars.slice(0, 5).forEach(pillar => {
        const thisWeek = thisWeekPillarTotals[pillar.id];
        const lastWeek = lastWeekPillarTotals[pillar.id];
        
        let trend, icon;
        if (lastWeek === 0 && thisWeek > 0) {
          trend = 'NEW activity';
          icon = 'üÜï';
        } else if (lastWeek === 0) {
          return; // Skip
        } else {
          const change = thisWeek - lastWeek;
          const pct = Math.round((change / lastWeek) * 100);
          
          if (pct > 20) {
            trend = `+${pct}% (${lastWeek} ‚Üí ${thisWeek})`;
            icon = '‚ÜóÔ∏è';
          } else if (pct < -20) {
            trend = `${pct}% (${lastWeek} ‚Üí ${thisWeek})`;
            icon = '‚ÜòÔ∏è';
          } else {
            trend = `steady (${thisWeek} tasks)`;
            icon = '‚Üí';
          }
        }
        
        const item = document.createElement('div');
        item.className = 'summary-item';
        item.setAttribute('data-icon', icon);
        item.textContent = `${pillar.name}: ${trend}`;
        trendsContainer.appendChild(item);
      });
    }

    // Render Goal Progress Metrics
    function renderGoalProgress() {
      const careerContainer = document.getElementById('careerMetricsGrid');
      const creativeContainer = document.getElementById('creativeMetricsGrid');
      const timeToGoalContainer = document.getElementById('timeToGoal');
      
      if (!careerContainer || !creativeContainer) return;

      const metrics = goalMetrics;
      
      // Career metrics
      careerContainer.innerHTML = `
        <div class="metric-card">
          <div class="metric-label">Total Applications</div>
          <div class="metric-value">${metrics.jobsApplied}</div>
          <div class="metric-change">Track in settings</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Interviews Scheduled</div>
          <div class="metric-value">${metrics.interviewsScheduled}</div>
          <div class="metric-change">${metrics.interviewsScheduled > 0 ? metrics.interviewsScheduled + ' active' : 'Keep applying!'}</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Networking Conversations</div>
          <div class="metric-value">${metrics.networkingConversations}</div>
          <div class="metric-change">Build relationships</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">LinkedIn Connections</div>
          <div class="metric-value">${metrics.linkedinConnections}</div>
          <div class="metric-change">Expand network</div>
        </div>
      `;

      // Creative metrics
      creativeContainer.innerHTML = `
        <div class="metric-card">
          <div class="metric-label">Instagram Followers</div>
          <div class="metric-value">${metrics.instagramFollowers.toLocaleString()}</div>
          <div class="metric-change">Growing audience</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">TikTok Followers</div>
          <div class="metric-value">${metrics.tiktokFollowers.toLocaleString()}</div>
          <div class="metric-change">Video reach</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Posts This Week</div>
          <div class="metric-value">${metrics.postsThisWeek}</div>
          <div class="metric-change">Target: 3-5</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Art Revenue</div>
          <div class="metric-value">$${metrics.artRevenue.toFixed(2)}</div>
          <div class="metric-change">${metrics.artRevenue === 0 ? 'Not launched yet' : 'Monthly total'}</div>
        </div>
      `;

      // Time to goal estimate
      if (timeToGoalContainer) {
        const applicationsPerWeek = 3; // Average from data
        const interviewRate = 0.05; // 5% of applications
        const targetApplications = 100; // Rough estimate to land role
        
        const remaining = Math.max(0, targetApplications - metrics.jobsApplied);
        const weeksRemaining = Math.ceil(remaining / applicationsPerWeek);
        const monthsRemaining = Math.ceil(weeksRemaining / 4);
        
        timeToGoalContainer.innerHTML = `
          <strong>‚è±Ô∏è TIME TO GOAL:</strong> Estimated ${monthsRemaining}-${monthsRemaining + 1} months based on current application rate
          ${metrics.interviewsScheduled > 0 ? ' (interviews in progress - could be sooner!)' : ''}
        `;
      }
    }

    // Settings functions
    function openSettings() {
      const overlay = document.getElementById('settingsOverlay');
      if (!overlay) return;

      // Populate pillar targets
      const pillarTargetsContainer = document.getElementById('pillarTargetsSettings');
      if (pillarTargetsContainer) {
        pillarTargetsContainer.innerHTML = '';
        pillars.forEach(pillar => {
          const row = document.createElement('div');
          row.className = 'settings-row';
          row.innerHTML = `
            <span class="settings-label">${pillar.name}</span>
            <input type="number" class="settings-input" id="target-${pillar.id}" 
                   value="${userSettings.pillarTargets[pillar.id]}" min="0" max="100" />
          `;
          pillarTargetsContainer.appendChild(row);
        });
      }

      // Populate goal weights
      const goalWeightsContainer = document.getElementById('goalWeightsSettings');
      if (goalWeightsContainer) {
        goalWeightsContainer.innerHTML = '';
        pillars.forEach(pillar => {
          const row = document.createElement('div');
          row.className = 'settings-row';
          row.innerHTML = `
            <span class="settings-label">${pillar.name}</span>
            <input type="number" class="settings-input" id="weight-${pillar.id}" 
                   value="${userSettings.goalWeights[pillar.id]}" min="1" max="10" />
          `;
          goalWeightsContainer.appendChild(row);
        });
      }

      // Populate other settings
      document.getElementById('workHoursInput').value = userSettings.workHoursPerWeek;
      document.getElementById('availableHoursInput').value = userSettings.availableHoursPerDay;

      // Populate goal metrics
      document.getElementById('jobsAppliedInput').value = goalMetrics.jobsApplied;
      document.getElementById('interviewsInput').value = goalMetrics.interviewsScheduled;
      document.getElementById('networkingInput').value = goalMetrics.networkingConversations;
      document.getElementById('linkedinInput').value = goalMetrics.linkedinConnections;
      document.getElementById('instagramInput').value = goalMetrics.instagramFollowers;
      document.getElementById('tiktokInput').value = goalMetrics.tiktokFollowers;
      document.getElementById('postsInput').value = goalMetrics.postsThisWeek;
      document.getElementById('revenueInput').value = goalMetrics.artRevenue;

      overlay.classList.add('visible');
    }

    function closeSettings() {
      const overlay = document.getElementById('settingsOverlay');
      if (overlay) overlay.classList.remove('visible');
    }

    function saveSettings() {
      // Save pillar targets
      pillars.forEach(pillar => {
        const input = document.getElementById(`target-${pillar.id}`);
        if (input) userSettings.pillarTargets[pillar.id] = parseFloat(input.value) || 0;
      });

      // Save goal weights
      pillars.forEach(pillar => {
        const input = document.getElementById(`weight-${pillar.id}`);
        if (input) userSettings.goalWeights[pillar.id] = parseInt(input.value) || 1;
      });

      // Save other settings
      userSettings.workHoursPerWeek = parseFloat(document.getElementById('workHoursInput').value) || 45;
      userSettings.availableHoursPerDay = parseFloat(document.getElementById('availableHoursInput').value) || 3;

      // Save goal metrics
      goalMetrics.jobsApplied = parseInt(document.getElementById('jobsAppliedInput').value) || 0;
      goalMetrics.interviewsScheduled = parseInt(document.getElementById('interviewsInput').value) || 0;
      goalMetrics.networkingConversations = parseInt(document.getElementById('networkingInput').value) || 0;
      goalMetrics.linkedinConnections = parseInt(document.getElementById('linkedinInput').value) || 0;
      goalMetrics.instagramFollowers = parseInt(document.getElementById('instagramInput').value) || 0;
      goalMetrics.tiktokFollowers = parseInt(document.getElementById('tiktokInput').value) || 0;
      goalMetrics.postsThisWeek = parseInt(document.getElementById('postsInput').value) || 0;
      goalMetrics.artRevenue = parseFloat(document.getElementById('revenueInput').value) || 0;

      localStorage.setItem(STORAGE_SETTINGS_KEY, JSON.stringify(userSettings));
      localStorage.setItem(STORAGE_GOAL_METRICS_KEY, JSON.stringify(goalMetrics));

      closeSettings();
      
      // Refresh all analytics
      renderPriorityAlignment();
      renderRecommendations();
      renderGoalProgress();
    }

    // Update all new analytics
    function updateNewAnalytics() {
      renderPriorityAlignment();
      renderStreaks();
      renderRecommendations();
      renderWeeklySummary();
      renderGoalProgress();
    }

    function init() {
      loadState();
      const dateDisplay = document.getElementById("dateDisplay");
      if (dateDisplay) {
        dateDisplay.textContent = formatPrettyDate() + " ¬∑ Daily progress resets";
      }
      renderGrid();
      updateTodayReflection();
      updateStatsUI();
      updateStreakUI();
      renderBadges();
      renderGrowthInsights();
      updateTimeRangeButtons();
      updatePillarBalance();
      
      // Initialize new analytics
      updateNewAnalytics();
      
      // Set up settings button
      const settingsBtn = document.getElementById('settingsBtn');
      if (settingsBtn) {
        settingsBtn.addEventListener('click', openSettings);
      }
      
      const settingsClose = document.getElementById('settingsClose');
      if (settingsClose) {
        settingsClose.addEventListener('click', closeSettings);
      }
      
      const settingsOverlay = document.getElementById('settingsOverlay');
      if (settingsOverlay) {
        settingsOverlay.addEventListener('click', (e) => {
          if (e.target === settingsOverlay) closeSettings();
        });
      }
      
      const settingsSaveBtn = document.getElementById('settingsSaveBtn');
      if (settingsSaveBtn) {
        settingsSaveBtn.addEventListener('click', saveSettings);
      }
      
      // Set up achievements toggle
      const achievementsToggle = document.getElementById('achievementsToggle');
      const achievementsGrid = document.getElementById('achievementsGrid');
      const achievementsArrow = document.getElementById('achievementsArrow');
      if (achievementsToggle && achievementsGrid && achievementsArrow) {
        achievementsToggle.addEventListener('click', () => {
          const isHidden = achievementsGrid.style.display === 'none';
          achievementsGrid.style.display = isHidden ? 'grid' : 'none';
          achievementsArrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
        });
      }
      
      // Set up time range selector
      document.querySelectorAll('.time-range-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const range = e.currentTarget.dataset.range;
          selectedTimeRange = range;
          
          // Update active state
          document.querySelectorAll('.time-range-btn').forEach(b => b.classList.remove('active'));
          e.currentTarget.classList.add('active');
          
          // Refresh button counts and balance view
          updateTimeRangeButtons();
          updatePillarBalance();
        });
      });
    }

    init();
  </script>
</body>
</html>
